<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐磊的个人博客</title>
  
  <subtitle>记录我的学习、生活、工作。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.tanglei.name/"/>
  <updated>2020-07-09T15:00:32.566Z</updated>
  <id>https://www.tanglei.name/</id>
  
  <author>
    <name>tanglei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这 10 行比较字符串相等的代码给我整懵逼了，不信你也来看看</title>
    <link href="https://www.tanglei.name/blog/timing-attack-of-safe-equals.html"/>
    <id>https://www.tanglei.name/blog/timing-attack-of-safe-equals.html</id>
    <published>2020-06-25T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.566Z</updated>
    
    <content type="html"><![CDATA[<p>抱歉用这种标题吸引你点进来了，不过你不妨看完，看看能否让你有所收获。​（有收获，请评论区留个言，没收获，下周末我直播吃**，哈哈，这你也信）</p><blockquote><p>补充说明：微信公众号改版，对各个号主影响还挺大的。目前从后台数据来看，对我影响不大，因为我这反正都是小号，😂阅读量本身就少的可怜，真相了，🐶狗头（刚从交流群学会的表情）。</p></blockquote><p>先直接上代码： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">safeEqual</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (a.length() != b.length()) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> equal = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">       equal |= a.charAt(i) ^ b.charAt(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> equal == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是我根据原版（<code>Scala</code>）翻译成 <code>Java</code>的，<code>Scala</code> 版本（最开始吸引程序猿石头注意力的代码）如下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safeEqual</span></span>(a: <span class="type">String</span>, b: <span class="type">String</span>) = &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.length != b.length) &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> equal = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="type">Array</span>.range(<span class="number">0</span>, a.length)) &#123;</span><br><span class="line">      equal |= a(i) ^ b(i)</span><br><span class="line">    &#125;</span><br><span class="line">    equal == <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始看到这段源码感觉挺奇怪的，这个函数的功能是比较两个字符串是否相等，首先“长度不等结果肯定不等，立即返回”这个很好理解。</p><p>再看看后面的，稍微动下脑筋，转弯下也能明白这其中的门道：通过异或操作<code>1^1=0, 1^0=1, 0^0=0</code>，来比较每一位，如果每一位都相等的话，两个字符串肯定相等，最后存储累计异或值的变量<code>equal</code>必定为 0，否则为 1。</p><h2 id="再细想一下呢？"><a href="#再细想一下呢？" class="headerlink" title="再细想一下呢？"></a>再细想一下呢？</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="type">Array</span>.range(<span class="number">0</span>, a.length)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a(i) ^ b(i) != <span class="number">0</span>) <span class="comment">// or a(i) != b[i]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们常常讲性能优化，从效率角度上讲，难道不是应该只要中途发现某一位的结果不同了（即为1）就可以立即返回两个字符串不相等了吗？(如上所示) </p><p>这其中肯定有……</p><p><img src="https://imgkr.cn-bj.ufileos.com/0d90724a-9e67-42ff-9db5-53453fba1abf.png" alt></p><h2 id="再再细想一下呢？"><a href="#再再细想一下呢？" class="headerlink" title="再再细想一下呢？"></a>再再细想一下呢？</h2><p>结合方法名称 <code>safeEquals</code> 可能知道些眉目，与安全有关。</p><blockquote><p>本文开篇的代码来自playframewok 里用来验证cookie(session)中的数据是否合法(包含签名的验证)，也是石头写这篇文章的由来。</p></blockquote><p>以前知道通过延迟计算等手段来提高效率的手段，但这种已经算出结果却延迟返回的，还是头一回！</p><p>我们来看看，JDK 中也有类似的方法，如下代码摘自 <code>java.security.MessageDigest</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">byte</span>[] digesta, <span class="keyword">byte</span>[] digestb)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (digesta == digestb) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (digesta == <span class="keyword">null</span> || digestb == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (digesta.length != digestb.length) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// time-constant comparison</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digesta.length; i++) &#123;</span><br><span class="line">       result |= digesta[i] ^ digestb[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释知道了，目的是为了用常量时间复杂度进行比较。</p><p>但这个计算过程耗费的时间不是常量有啥风险？ （脑海里响起了背景音乐：“小朋友，你是否有很多问号？”）</p><p><img src="https://imgkr.cn-bj.ufileos.com/327a7a80-6fd7-4b4f-b836-78fc9399ce34.png" alt></p><h2 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h2><p>再深入探索和了解了一下，原来这么做是为了防止<strong>计时攻击</strong>（Timing Attack）。（也有人翻译成时序攻击​）​</p><p><img src="https://imgkr.cn-bj.ufileos.com/43ae6be8-c869-4bfa-bab9-77435893afb4.png" alt></p><h2 id="计时攻击-Timing-Attack"><a href="#计时攻击-Timing-Attack" class="headerlink" title="计时攻击(Timing Attack)"></a>计时攻击(Timing Attack)</h2><p>计时攻击是边信道攻击(或称”侧信道攻击”， Side Channel Attack， 简称SCA) 的一种，边信道攻击是一种针对软件或硬件设计缺陷，走“歪门邪道”的一种攻击方式。</p><p>这种攻击方式是通过功耗、时序、电磁泄漏等方式达到破解目的。在很多物理隔绝的环境中，往往也能出奇制胜，这类新型攻击的有效性<strong>远高于</strong>传统的密码分析的数学方法（某百科上说的）。</p><p>这种手段可以让调用 <code>safeEquals(&quot;abcdefghijklmn&quot;, &quot;xbcdefghijklmn&quot;)</code> （只有首位不相同）和调用 <code>safeEquals(&quot;abcdefghijklmn&quot;, &quot;abcdefghijklmn&quot;)</code> （两个完全相同的字符串）的所耗费的时间一样。防止通过大量的改变输入并通过统计运行时间来暴力破解出要比较的字符串。 </p><p>举个🌰，如果用之前说的“高效”的方式来实现的话。假设某个用户设置了密码为 <code>password</code>，通过从a到z（实际范围可能更广）不断枚举第一位，最终统计发现 <code>p0000000</code> 的运行时间比其他从任意<code>a~z</code>的都长（因为要到第二位才能发现不同，其他非 <code>p</code> 开头的字符串第一位不同就直接返回了），这样就能猜测出用户密码的第一位很可能是<code>p</code>了，然后再不断一位一位迭代下去最终破解出用户的密码。</p><p>当然，以上是从理论角度分析，确实容易理解。但实际上好像通过统计运行时间总感觉不太靠谱，这个运行时间对环境太敏感了，比如网络，内存，CPU负载等等都会影响。</p><p>但安全问题感觉更像是 “宁可信其有，不可信其无”。为了防止(特别是与签名/密码验证等相关的操作)被 <strong>timing attack</strong>，目前各大语言都提供了相应的安全比较函数。各种软件系统（例如 OpenSSL）、框架（例如 Play）的实现也都采用了这种方式。 </p><p>例如 “世界上最好的编程语言”（粉丝较少，评论区应该打不起架来）—— php中的: </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compares two strings using the same time whether they're equal or not.</span></span><br><span class="line"><span class="comment">// This function should be used to mitigate timing attacks; </span></span><br><span class="line"><span class="comment">// for instance, when testing crypt() password hashes.</span></span><br><span class="line">bool hash_equals ( string $known_string , string $user_string )</span><br><span class="line"></span><br><span class="line"><span class="comment">//This function is safe against timing attacks.</span></span><br><span class="line">boolean password_verify ( string $password , string $hash )</span><br></pre></td></tr></table></figure><p>其实各种语言版本的实现方式都与上面的版本差不多，将两个字符串每一位取出来异或(<code>^</code>)并用或(<code>|</code>)保存，最后通过判断结果是否为 0 来确定两个字符串是否相等。 </p><p>如果刚开始没有用 <code>safeEquals</code> 去实现，后续的版本还会通过打补丁的方式去修复这样的安全隐患。  </p><p>例如 <a href="http://www.oracle.com/technetwork/java/javase/6u17-141447.html" title="Release Notes" target="_blank" rel="noopener">JDK 1.6.0_17 中的Release Notes</a>中就提到了<code>MessageDigest.isEqual</code> 中的bug的修复，如下图所示：</p><p><img src="https://static01.imgkr.com/temp/7e264b6f9f6141e9a779f07bd29ebd64.png" alt="MessageDigest timing attack vulnerabilities"></p><p>大家可以看看这次变更的的详细信息<a href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/rev/562da0baf70b" title="openjdk中的 bug fix diff" target="_blank" rel="noopener">openjdk中的 bug fix diff</a>为：</p><p><img src="https://static01.imgkr.com/temp/87adf41576964e8bafb2abf48c6a95ab.png" alt="MessageDigest.isEqual计时攻击"></p><h2 id="Timing-Attack-真的可行吗？"><a href="#Timing-Attack-真的可行吗？" class="headerlink" title="Timing Attack 真的可行吗？"></a>Timing Attack 真的可行吗？</h2><p>我觉得各大语言的 API 都用这种实现，肯定还是有道理的，理论上应该可以被利用的。<br>这不，学术界的这篇论文就宣称用这种计时攻击的方法破解了 <code>OpenSSL 0.9.7</code> 的RSA加密算法了。关于 <a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=100000109&amp;idx=1&amp;sn=e65143adf4f81cc5c559b03c58d029e9&amp;chksm=6b4700895c30899f6148025c6120844bd0aeb2d09413ad4ece33f2ea49296fa6f54d17447f63#rd" target="_blank" rel="noopener">RSA 算法的介绍</a>可以看看之前本人写的这篇文章。 </p><p>这篇<a href="http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf" title="Remote Timing Attacks are Practical" target="_blank" rel="noopener">Remote Timing Attacks are Practical</a> 论文中指出（我大致翻译下摘要，感兴趣的同学可以通过文末链接去看原文）：</p><p>计时攻击往往用于攻击一些性能较弱的计算设备，例如一些智能卡。我们通过实验发现，也能用于攻击普通的软件系统。本文通过实验证明，通过这种计时攻击方式能够攻破一个基于 OpenSSL 的 web 服务器的私钥。结果证明计时攻击用于进行网络攻击在实践中可行的，因此各大安全系统需要抵御这种风险。</p><p>最后，本人毕竟不是专研完全方向，以上描述是基于本人的理解，如果有不对的地方，还请大家留言指出来。感谢。</p><blockquote><p>补充说明2：感谢正在阅读文章的你，让我还有动力继续坚持更新原创。</p><p>本人发文不多，但希望写的文章能达到的目的是：占用你的阅读时间，就尽量能够让你有所收获。</p><p>如果你觉得我的文章有所帮助，还请你帮忙转发分享，另外请别忘了点击公众号右上角加个星标，好让你别错过后续的精彩文章（微信改版了，或许我发的文章都不能推送到你那了）。</p></blockquote><p>​原创真心不易，希望你能帮我个小忙呗，如果本文内容你觉得有所启发，有所收获，请帮忙点个“在看”呗，或者转发分享让更多的小伙伴看到。<br>​<br>参考资料：</p><ul><li><a href="http://www.cs.sjsu.edu/faculty/stamp/students/article.html" target="_blank" rel="noopener">Timing Attacks on RSA: Revealing Your Secrets through the Fourth Dimension</a></li><li><a href="http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf" target="_blank" rel="noopener">Remote Timing Attacks are Practical</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;抱歉用这种标题吸引你点进来了，不过你不妨看完，看看能否让你有所收获。​（有收获，请评论区留个言，没收获，下周末我直播吃**，哈哈，这你也信）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;补充说明：微信公众号改版，对各个号主影响还挺大的。目前从后台数据来看，对我影响不大，因为我这
      
    
    </summary>
    
      <category term="MyLife" scheme="https://www.tanglei.name/categories/MyLife/"/>
    
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
      <category term="网络安全" scheme="https://www.tanglei.name/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一行代码引来的安全漏洞就让我们丢失了整个服务器的控制权</title>
    <link href="https://www.tanglei.name/blog/a-security-vulnerability-of-spring-validator.html"/>
    <id>https://www.tanglei.name/blog/a-security-vulnerability-of-spring-validator.html</id>
    <published>2020-05-24T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.566Z</updated>
    
    <content type="html"><![CDATA[<p>之前在某厂的某次项目开发中，项目组同学设计和实现了一个“引以为傲”，额，有点扩张，不过自认为还说得过去的 feature，结果临上线前被啪啪打脸，因为实现过程中因为<strong>一行代码</strong>（没有标题党，真的是一行代码）带来的安全漏洞让我们丢失了整个服务器控制权（测试环境）。多亏了上线之前有公司安全团队的人会对代码进行扫描，才让这个漏洞被扼杀在摇篮里。</p><p>下面我们就一起来看看这个事故，啊，不对，是故事。</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/gif-0.png" alt></p><h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>我们的项目是一个面向全球用户的 Web 项目，用 SpringBoot 开发。在项目开发过程中，离不开各种异常信息的处理，比如表单提交参数不符合预期，业务逻辑的处理时离不开各种异常信息（例如网络抖动等）的处理。于是利用 SpringBoot 各种现成的组件支持，设计了一个统一的异常信息处理组件，统一管理各种业务流程中可能出现的错误码和错误信息，通过国际化的资源配置文件进行统一输出给用户。</p><h3 id="统一错误信息配置管理"><a href="#统一错误信息配置管理" class="headerlink" title="统一错误信息配置管理"></a>统一错误信息配置管理</h3><p>我们的用户遍布全球，为了给各个国家用户比较好的体验会进行不同的翻译。具体而言，实现的效果如下，为了方便理解，以“找回登录密码”这样一个业务场景来进行阐述说明。</p><p>假设找回密码时，需要用户输入手机或者邮箱验证码，假设这个时候用户输入的验证码通过后台数据库（可能是Redis）对比发现已经过期。在业务代码中，只需要简单的 <code>throw new ErrorCodeException(ErrorCodes.AUTHCODE_EXPIRED)</code> 即可。具体而言，针对不同国家地区不同的语言看到的效果不一样：</p><ul><li>中文用户看到的提示就是“您输入的验证码已过期，请重新获取”；</li><li>欧美用户看到的效果是“The verification code you input is expired, …”；</li><li>德国用户看到的是：“Der von Ihnen eingegebene Verifizierungscode ist abgelaufen, bitte wiederholen” 。（我瞎找的翻译，不一定准）</li><li>……</li></ul><h3 id="统一错误信息配置管理代码实现"><a href="#统一错误信息配置管理代码实现" class="headerlink" title="统一错误信息配置管理代码实现"></a>统一错误信息配置管理代码实现</h3><p>关键信息其实就在于一个 GlobalExceptionHandler，对所有Controller 入口进行 AOP 拦截，根据不同的错误信息，获取相应资源文件配置的 key，并从语言资源文件中读取不同国家的错误翻译信息。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BadRequestException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">BadRequestException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        String i18message = getI18nMessage(e.getKey(), request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(e.getCode(), i18message));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ErrorCodeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ErrorCodeException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        String i18message = getI18nMessage(e.getKey(), request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.OK).body(Response.error(e.getCode(), i18message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.tanglei.name/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-tree.png" alt="不同语言的资源文件示例"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getI18nMessage</span><span class="params">(String key, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, LanguaggeUtils.currentLocale(request));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">// log</span></span><br><span class="line">       <span class="keyword">return</span> key;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细代码实现可以参考本人之前写的这篇文章<a href="/blog/custom-validator-and-i18n-error-message-in-springboot.html">一文教你实现 SpringBoot 中的自定义 Validator 和错误信息国际化配置</a>，上面有附完整的代码实现。</p><h3 id="基于注解的表单校验（含自定义注解）"><a href="#基于注解的表单校验（含自定义注解）" class="headerlink" title="基于注解的表单校验（含自定义注解）"></a>基于注解的表单校验（含自定义注解）</h3><p>还有一种常见的业务场景就是后端接口需要对用户提交的表单进行校验。以“注册用户”这样的场景举例说明， 注册用户时，往往会提交昵称，性别，邮箱等信息进行注册，简单起见，就以这 3 个属性为例。</p><p>定义的表单如下：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegForm</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String nickname;</span><br><span class="line"><span class="keyword">private</span> String gender;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于表单的约束，我们有：</p><ul><li>昵称字段：“nickname” 必填，长度必须是 6 到 20 位；</li><li>性别字段：“gender” 可选，如果填了，就必须是“Male/Female/Other/”中的一种。说啥，除了男女还有其他？对，是的。毕竟全球用户嘛，你去看看非死不可，还有更多。</li><li>邮箱： “email”，必填，必须满足邮箱格式。</li></ul><p>对于以上约束，我们只需要在对应的字段上添加如下注解即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegForm</span> </span>&#123;</span><br><span class="line"><span class="meta">@Length</span>(min = <span class="number">6</span>, max = <span class="number">20</span>, message = <span class="string">"validate.userRegForm.nickname"</span>)</span><br><span class="line"><span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Gender</span>(message=<span class="string">"validate.userRegForm.gender"</span>)</span><br><span class="line"><span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="meta">@Email</span>(message=<span class="string">"validate.userRegForm.email"</span>)</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在各个语言资源文件中配置好相应的错误信息提示即可。其中， <code>@Gender</code> 就是一个自定义的注解。</p><h3 id="基于含自定义注解的表单校验关键代码"><a href="#基于含自定义注解的表单校验关键代码" class="headerlink" title="基于含自定义注解的表单校验关键代码"></a>基于含自定义注解的表单校验关键代码</h3><p>自定义注解的实现主要的其实就是一个自定义注解的定义以及一个校验逻辑。<br>例如定义一个自定义注解 <code>CustomParam</code>： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = CustomValidator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(</span>&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomParam &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "name.tanglei.www.validator.CustomArray.defaultMessage"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Target</span>(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;)</span><br><span class="line">    <span class="meta">@interface</span> List &#123;</span><br><span class="line">        CustomParam[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验逻辑的实现 <code>CustomValidator</code>： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">CustomParam</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == s || s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">"tanglei"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error(constraintValidatorContext, <span class="string">"Invalid params: "</span> + s);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(CustomParam constraintAnnotation)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(ConstraintValidatorContext context, String message)</span> </span>&#123;</span><br><span class="line">        context.disableDefaultConstraintViolation();</span><br><span class="line">        context.buildConstraintViolationWithTemplate(message).addConstraintViolation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子只为了阐述说明问题，其中校验逻辑没有实际意义，这样，如果输入参数不满足条件，就会明确提示用户输入的哪个参数不满足条件。例如输入参数 <code>xx</code>，则会直接提示：<code>Invalid params: xx</code>。</p><p><img src="https://www.tanglei.name/resources/custom-validator-and-i18n-error-message-in-springboot/validator-bug.png" alt></p><p>这个跟第一部分的处理方式类似，因为现有的 validator 组件实现中，如果违反相应的约束也是一种抛异常的方式实现的，因此只需要在上述的 <code>GlobalExceptionHandler</code>中添加相应的异常信息即可，这里就不详述了。  这不是本文的重点，这里就不详细阐述了。 详细代码实现可以参考本人之前写的这篇文章<a href="/blog/custom-validator-and-i18n-error-message-in-springboot.html">一文教你实现 SpringBoot 中的自定义 Validator 和错误信息国际化配置</a>，上面有附完整的代码实现。</p><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><p>一切都显得很完美，直到上线前代码提交至安全团队扫描，就被“啪啪打脸”，扫描报告反馈了一个严重的安全漏洞。而这个安全漏洞，属于很高危的远程代码执行漏洞。</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/gif-1.gif" alt></p><p>用前文提到的自定义 Validator，输入的参数用： “1+1=${1+1}”，看看效果： </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-calc-4wx.png" alt></p><p>太 TM 神奇了，居然帮我运算出来了，返回 <code>&quot;message&quot;: &quot;Invalid params: 1+1=2&quot;</code>。 </p><p>问题就出现在实现自定义注解进行校验的这行代码（如下图所示）：</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-line-4wx.png" alt></p><p>其实，最开始的时候，这里直接返回了“Invalid params”，当初为了更好的用户体验，要明确告诉用户哪个参数没有通过校验，因此在输出的提示上加上了用户输入的字段，也就是上面的<code>&quot;Invalid params: &quot; + s</code>，没想到，这闯了大祸了（回过头来想，感觉这里没必要这么详细啊，因为前端已经有相应的校验了，正常情况下回拦住，针对不守规矩的用非常规手段来的接口请求，直接返回校验不通过就行了，毕竟不是对外提供的 OpenAPI 服务）。</p><p>仔细看，这个方法实际上是 <code>ConstraintValidatorContext</code>这个接口中声明的，看方法名字其实能知道输入参数是一个字符串模板，内部会进行解析替换的（这其实也符合“见名知意”的良好编程习惯）。（教训：<strong>大家应该把握好自己写的每一行代码背后实际在做什么</strong>。）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ......</span></span><br><span class="line"><span class="comment"> * @param messageTemplate new un-interpolated constraint message</span></span><br><span class="line"><span class="comment"> * @return returns a constraint violation builder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ConstraintViolationBuilder <span class="title">buildConstraintViolationWithTemplate</span><span class="params">(String messageTemplate)</span></span>;</span><br></pre></td></tr></table></figure><p>这个 case，源码调试进去之后，就能跟踪到执行翻译阶段，在如下方法中： <code>org.hibernate.validator.messageinterpolation.AbstractMessageInterpolator.interpolateMessage</code>。  </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-interpolate-4wx.png" alt></p><p>再往后，就是表达式求值了。<br><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-plus11-4wx.png" alt></p><h3 id="以为就这样就完了吗？"><a href="#以为就这样就完了吗？" class="headerlink" title="以为就这样就完了吗？"></a>以为就这样就完了吗？</h3><p><img src="/resources/a-security-vulnerability-of-spring-validator/gif-2.jpeg" alt></p><p>刚开始感觉，能帮忙算简单的运算规则也就完了吧，你还能把我怎么样？其实这个相当于暴露了一个入口，支持用户输入任意 EL 表达式进行执行。网上通过关键字 “SpEL表达式注入漏洞” 找找，就能发现事情并没有想象中那么简单。</p><p>我们构造恰当的 EL 表达式（注意各种转义，下文的输入参数相对比较明显在做什么了，实际上还有更多黑科技，比如各种二进制转义编码啊等等），就能直接执行输入代码，例如：可以直接执行命令，“ls -al”， 返回了一个 UNIXProcess 实例，命令已经被执行过了。</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-run-process-4wx.png" alt></p><p>比如，我们执行个打开计算器的命令，搞个计算器玩玩~ </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-run-open-calc-4wx.png" alt></p><p>我录制了一个动图，来个演示可能更生动一些。 </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/spel-bug-demo-0.gif" alt></p><p>这还得了吗？这相当于提供了一个 webshell 的功能呀，你看想运行啥命令就能运行啥命令，例如 ping 本人博客地址（<code>ping www.tanglei.name</code>），下面动图演示一下整个过程（从运行 ping 到 kill ping）。</p><p><img src="/resources/a-security-vulnerability-of-spring-validator/spel-demo-ping.gif" alt></p><p>我录制了一个视频，点击<a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=100001493&amp;idx=1&amp;sn=d8d2374d8afa76e55bd37650c7ccde45&amp;chksm=6b4707315c308e273f4eb62799c65677d849104125bb6e7a56fbded981554fb92e97c289804e#rd" target="_blank" rel="noopener">这里</a>可以访问。</p><p>岂不是直接创建一个用户，然后远程登录就可以了。后果很严重啊，别人想干嘛就干嘛了。 </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/gif-3.gif" alt></p><p>我们跟踪下对应的代码，看看内部实现，就会“恍然大悟”了。 </p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-el-express-4wx.png" alt></p><p><img src="/resources/a-security-vulnerability-of-spring-validator/security-bug-el-express-run-4wx.png" alt></p><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><p>幸亏这个漏洞被扼杀在摇篮里，否则后果还真的挺严重的。通过这个案例，我们有啥经验和教训呢？那就是作为程序员，<strong>我们要对每一行代码都保持“敬畏”之心</strong>。也许就是因为你的不经意的一行代码就带来了严重的安全漏洞，要是不小心被坏人利用，轻则……重则……（自己想象吧） </p><p>此外，我们也应该看到，程序员需要对常见的安全漏洞（例如XSS/CSRF/SQL注入等等）有所了解，并且要有足够的安全意识（其实有时候研究一些安全问题还挺好玩的，比如这篇<a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483759&amp;idx=1&amp;sn=9b37547a51ac99a8d3d50cb9cf54a99a&amp;chksm=eb47008bdc30899dace5743edfc071d97d37764ed69bd9cebbfe32c14727a7407a6b8b76a433&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《RSA算法及一种”旁门左道”的攻击方式》</a>就比较有趣）。例如：</p><ul><li>用户权限分离：运行程序的用户不应该用 root，例如新建一个“web”或者“www”之类的用户，并设置该用户的权限，比如不能有可执行 xx 的权限之类的。本文 case，如果权限进行了分离（遵循最小权限原则），应该也不会这么严重。（本文就刚好是因为是测试环境，所以没有强制实施）</li><li>任何时候都不要相信用户的输入，必须对用户输入的进行校验和过滤，又特别是针对公网上的应用。</li><li>敏感信息加密保存。退一万步讲，假设攻击者攻入了你的服务器，如果这个时候，你的数据库账户信息等配置都直接明文保存在服务器中。那数据库也被脱走了。</li></ul><p>如果可能的话，需要对开发者的代码进行漏洞扫描。一些常见的安全漏洞现在应该是有现成的工具支持的。另外，让专业的人做专业的事情，例如要有安全团队，可能你会说你们公司没有不也活的好好的，哈哈，只不过可能还没有被坏人盯上而已，坏人也会考虑到他们的成本和预期收益的，当然这就更加对我们开发者提高了要求。一些敏感权限尽量控制在少部分人手中，配合相应的流程来支撑（不得不说，大公司繁琐的流程还是有一定道理的）。</p><p>毕竟我不是专业研究Web安全的，以上说得可能也不一定对，如果你有不同意见或者更好的建议欢迎留言参与讨论。</p><p>这篇文章从写代码做实验，到录屏做视频动图等等耗时还蛮久的（好几个周末的时间呢），原创真心不易，希望你能帮我个小忙呗，如果本文内容你觉得有所启发，有所收获，请帮忙点个“在看”呗，或者转发分享让更多的小伙伴看到。</p><h5 id="精彩推荐"><a href="#精彩推荐" class="headerlink" title="精彩推荐"></a>精彩推荐</h5><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483933&amp;idx=1&amp;sn=69b1be012cf37ccb5ce6f3a091f57f5b&amp;chksm=eb4703f9dc308aef5834a6abf72255edd1767e633330531f817d7b4774c65c33f5910cd9ea75&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">一个由跨平台产生的浮点数bug | 有你意想不到的结果。</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483759&amp;idx=1&amp;sn=9b37547a51ac99a8d3d50cb9cf54a99a&amp;chksm=eb47008bdc30899dace5743edfc071d97d37764ed69bd9cebbfe32c14727a7407a6b8b76a433&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">RSA算法及一种”旁门左道”的攻击方式。</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483891&amp;idx=1&amp;sn=264171adf872514d1fd54faf54970dd7&amp;chksm=eb470017dc3089019ffc13facfdfb38e9d5f2adaf7fcbf9c117723ce015fb660f0802d406c7b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">震惊! 阿里的程序员也不过如此,竟被一个简单的 SQL 查询难住。</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483912&amp;idx=1&amp;sn=520bbca6a2056ab4df6b0e1d0ebaf6e0&amp;chksm=eb4703ecdc308afa83b288b1469f0927c1916189f219ee5e8c3c5194defc0b8f313ff7607730&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">面了7轮 Google，最终还是逃不脱被挂的命运。</a></li></ul><blockquote><p>文章首发于本人微信公众号（ID：<code>tangleithu</code>），请感兴趣的同学关注我的微信公众号，及时获取技术干货。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在某厂的某次项目开发中，项目组同学设计和实现了一个“引以为傲”，额，有点扩张，不过自认为还说得过去的 feature，结果临上线前被啪啪打脸，因为实现过程中因为&lt;strong&gt;一行代码&lt;/strong&gt;（没有标题党，真的是一行代码）带来的安全漏洞让我们丢失了整个服务器控
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Java" scheme="https://www.tanglei.name/tags/Java/"/>
    
      <category term="网络安全" scheme="https://www.tanglei.name/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一文教你实现 SpringBoot 中的自定义 Validator 和错误信息国际化配置</title>
    <link href="https://www.tanglei.name/blog/custom-validator-and-i18n-error-message-in-springboot.html"/>
    <id>https://www.tanglei.name/blog/custom-validator-and-i18n-error-message-in-springboot.html</id>
    <published>2020-05-16T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.566Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-title.png" alt></p><p>本文通过示例说明，在 Springboot 中如何自定义 Validator，以及如何实现国际化的错误信息返回。注意，本文代码千万别直接照抄，有可能会出大事情的。先留个悬念，读者朋友们能从中看出有什么问题吗？</p><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>直接从 <a href="https://spring.io/guides/gs/rest-service/#initial" target="_blank" rel="noopener">springboot</a> 官网中下载模板，直接通过示例中的 <code>GreetingController</code> 添加实现逻辑。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String template = <span class="string">"Hello, %s!"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/greeting"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;Greeting&gt; <span class="title">greeting</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, defaultValue = <span class="string">"World"</span>)</span> String name) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="string">"tangleithu"</span>.equals(name)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">"user.notFound"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Response.ok(<span class="keyword">new</span> Greeting(counter.incrementAndGet(), String.format(template, name)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码直接源自<a href="https://github.com/spring-guides/gs-rest-service.git" target="_blank" rel="noopener">官方 spring-guides 的 demo</a>，我稍微改吧改吧。正常情况下，能返回正确的结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># curl "localhost:8080/greeting?name=tangleithu&amp;lang=en" </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"content"</span>: <span class="string">"Hello, tangleithu!"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">9</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"success"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="国际化需求"><a href="#国际化需求" class="headerlink" title="国际化需求"></a>国际化需求</h2><p>作为高大上的项目，我们肯定有海外用户，所以就需要国际化的配置。现在来模拟了下业务逻辑，假设输入的参数有一些校验功能，比如以上name参数，假设和“tangleithu”不相等，就直接返回错误。同时希望返回的错误信息需要实现国际化，即在不同的语言环境下返回的结果不一样。例如中文：“没找到用户呢。” 对应的英文：“User does not exist.”，而对应的德文是……，算了忽略，我也不会。</p><p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-demo.png" alt></p><p>用一个图来表达，即希望实现的效果是，不同国家和地区的用户（不同语言）在遇到同一个业务场景下同一个错误原因，有不同的翻译。例如在参数校验没通过，Http Status Code应该返回 400，并告知错误原因；在具体的 Service 实现时可能也会遇到其他的 case 需要返回某种具体错误信息。</p><p>注意：实际业务场景中后端可能仅仅只返回错误码，具体的展示由前端根据 key 进行翻译。不过在一些更加灵活的场景中（例如有的 app 实现方案），错误信息很有可能会由后端接口直接返回。本文只是用了一个简单的案例阐述整个流程。</p><h2 id="统一错误处理"><a href="#统一错误处理" class="headerlink" title="统一错误处理"></a>统一错误处理</h2><p>​我们借助 Spring 中的 AOP，用一个 <code>ControllerAdvice</code> 统一拦截这种 <code>BadRequestException</code>异常。其他 Exception 也一样，做到异常信息统一处理，也不容易出现安全风险（之前有遇到过某大型网站因为后台发生异常，直接将具体的 SQL 错误暴露出来了，其中还不乏有表结构等敏感信息）。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BadRequestException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">BadRequestException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        String i18message = getI18nMessage(e.getKey(), request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(e.getCode(), i18message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="国际化配置"><a href="#国际化配置" class="headerlink" title="国际化配置"></a>国际化配置</h2><p>然后，我们在这种具体的异常信息时，用一个 key 来标记错误码，在资源文件中用不同的语言来定义应该返回的具体错误信息。例如本文示例中，添加了中英文两种。 相应的目录结构如下： </p><p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-tree.png" alt></p><p>此时，我们只需要在 <code>GlobalExceptionHandler</code> 中根据请求来源是中文还是英文返回对应的错误信息即可。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getI18nMessage</span><span class="params">(String key, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> messageSource.getMessage(key, <span class="keyword">null</span>, LanguaggeUtils.currentLocale(request));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">// log</span></span><br><span class="line">       <span class="keyword">return</span> key;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从请求来源获取语言信息就有多种方式啦，例如我们可以从请求头中获取 <code>Accept-Lanuage</code>，一般浏览器会根据用户的设置情况带上这个请求头的，如下图所示。</p><p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-header.png" alt></p><p>或者我们自己显示定义一些例如 lang 之类的参数。本文不做详细阐述，咱们就简单用 <code>lang</code> 这个参数来定义，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LanguaggeUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Locale <span class="title">currentLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 RequestHeader 等等获取相应的语言信息</span></span><br><span class="line">        <span class="comment">// 简单起见，直接从 queryParams 中取, 只模拟中英文</span></span><br><span class="line">        String locale = request.getParameter(<span class="string">"lang"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"zh"</span>.equalsIgnoreCase(locale)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Locale.CHINA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Locale.ENGLISH;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过简单几行代码就能实现高大上的“国际化”参数返回了。 试试效果如下： </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#curl "localhost:8080/greeting?name=tanglei&amp;lang=en" </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"User does not exist."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#curl "localhost:8080/greeting?name=tanglei&amp;lang=zh" </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"没找到用户呢。"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean-Validator"><a href="#Bean-Validator" class="headerlink" title="Bean Validator"></a>Bean Validator</h2><p>其实针对类似 Form 等参数校验，我们有更简单的方法。那就是借助 SpringBoot 中自带的 Validation 框架，本文用到的这个版本对应的实现是<code>jakarta.validation-api</code>。其实 Bean Validation 都有相应的标准，可能有不同的具体实现而已。对标准感兴趣的可以戳这里<a href="https://www.jcp.org/en/egc/view?id=380" target="_blank" rel="noopener">JSR #380 Bean Validation 2.0</a>。</p><p>回到本文的 demo 中，假设在我们业务逻辑中需要传递一个 <code>UserForm</code>，接收 <code>age,name,param</code> 三个参数。并对其中输入进行进行校验，其中，<code>param</code> 没有具体的含义，只是为了说明问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserForm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">0</span>, message = <span class="string">"validate.userform.age"</span>)</span><br><span class="line">    <span class="meta">@Max</span>(value = <span class="number">120</span>, message = <span class="string">"validate.userform.age"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"validate.userform.name.notEmpty"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CustomParam</span>(message = <span class="string">"validate.userform.param.custom"</span>)</span><br><span class="line">    <span class="keyword">private</span> String param;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;Greeting&gt; <span class="title">createUser</span><span class="params">(@Valid @RequestBody UserForm userForm)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Response.ok(<span class="keyword">new</span> Greeting(counter.incrementAndGet(), String.format(template, userForm.getName())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上，上面示例只用了很简单的 <code>@Min, @Max, @NotNull</code>等约束条件，通过名字就能看出来含义。更多约束规则可以直接看对应源码 <code>javax.validation.constraints.xxx</code>，比如有常见的 <code>Email</code> 等格式校验。 </p><p>默认情况下，违反相应的约束条件后，默认的输出比较啰嗦，例如用这个请求 <code>curl -H &quot;Content-Type: application/json&quot; -d &quot;{}&quot; &quot;localhost:8080/user&quot;</code>，对应的输出如下： </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"Bad Request"</span>,</span><br><span class="line">    <span class="attr">"errors"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"arguments"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"arguments"</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">"code"</span>: <span class="string">"name"</span>,</span><br><span class="line">                    <span class="attr">"codes"</span>: [</span><br><span class="line">                        <span class="string">"userForm.name"</span>,</span><br><span class="line">                        <span class="string">"name"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"defaultMessage"</span>: <span class="string">"name"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"bindingFailure"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"code"</span>: <span class="string">"NotBlank"</span>,</span><br><span class="line">            <span class="attr">"codes"</span>: [</span><br><span class="line">                <span class="string">"NotBlank.userForm.name"</span>,</span><br><span class="line">                <span class="string">"NotBlank.name"</span>,</span><br><span class="line">                <span class="string">"NotBlank.java.lang.String"</span>,</span><br><span class="line">                <span class="string">"NotBlank"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defaultMessage"</span>: <span class="string">"must not be blank"</span>,</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"name"</span>,</span><br><span class="line">            <span class="attr">"objectName"</span>: <span class="string">"userForm"</span>,</span><br><span class="line">            <span class="attr">"rejectedValue"</span>: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Validation failed for object='userForm'. Error count: 1"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/user"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="string">"2020-05-10T08:44:12.952+0000"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实依葫芦画瓢，debug 的时候，把抛出的具体异常添加到前面的 <code>GlobalExceptionHandler</code>，再修改下默认的行为即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(BindException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">BindException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">   String key = e.getBindingResult().getAllErrors().get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">   String i18message = getI18nMessage(key, request);</span><br><span class="line">   <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(<span class="number">400</span>, i18message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">MethodArgumentNotValidException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">   String key = e.getBindingResult().getAllErrors().get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">   String i18message = getI18nMessage(key, request);</span><br><span class="line">   <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(<span class="number">400</span>, i18message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(ConstraintViolationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">ConstraintViolationException</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">   String key = e.getConstraintViolations().iterator().next().getMessage();</span><br><span class="line">   String i18message = getI18nMessage(key, request);</span><br><span class="line">   <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Response.error(<span class="number">400</span>, i18message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后，增加自定义的 handler 后，返回信息结构一致方便前端统一处理，同时也简洁不少：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"validate.userform.name.notEmpty"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再结合前面讲解的通过i18n的参数配置，又可以实现当没通过校验的时候，错误信息统一由对应的国际化资源文件进行配置了。 </p><h2 id="自定义-Validator"><a href="#自定义-Validator" class="headerlink" title="自定义 Validator"></a>自定义 Validator</h2><p>当内置的满足不了条件的时候，我们希望实现自定义的 Validator，例如前文中的 <code>CustomParam</code>。</p><p>我们需要一个 Annotation，方便在对应 Form 的时候引用校验，具体实现如下： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = CustomValidator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(</span>&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomParam &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "name.tanglei.www.validator.CustomArray.defaultMessage"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Target</span>(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;)</span><br><span class="line">    <span class="meta">@interface</span> List &#123;</span><br><span class="line">        CustomParam[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要一个具体的 validator 实现类，通过上面的 <code>@Constraint(validatedBy = CustomValidator.class)</code> 关联起来。本文只是 demo，所以具体参数校验没有实际逻辑意义的，下面假设输入的参数和“tanglei”相同则校验通过，否则提示用户输入错误。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">CustomParam</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == s || s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">"tanglei"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error(constraintValidatorContext, <span class="string">"Invalid params: "</span> + s);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(CustomParam constraintAnnotation)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(ConstraintValidatorContext context, String message)</span> </span>&#123;</span><br><span class="line">        context.disableDefaultConstraintViolation();</span><br><span class="line">        context.buildConstraintViolationWithTemplate(message).addConstraintViolation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看效果，输入没校验通过，还提示你输入的参数 “xx” 不符合条件。</p><p><img src="/resources/custom-validator-and-i18n-error-message-in-springboot/validator-bug.png" alt></p><p>是不是感觉很完美？</p><blockquote><p>注意：上文中有一个比较隐蔽的安全漏洞，请大家注意。</p><blockquote><p>注意：上文中有一个比较隐蔽的安全漏洞，请大家注意。</p><blockquote><p>注意：上文中有一个比较隐蔽的安全漏洞，请大家注意。</p></blockquote></blockquote></blockquote><p>重要的事情说三遍，总体来说本文思路还是值得借鉴的（对应代码见 <a href="https://github.com/tl3shi/demo.git" target="_blank" rel="noopener">github</a>），但一定要注意不要完全照抄，上面说的这个安全漏洞还挺严重的。给予点提示，就是在<code>CustomValidator</code> 的具体实现中，有朋友了解吗？欢迎留言讨论。我将在后面的文章中来讲述这个安全漏洞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/resources/custom-validator-and-i18n-error-message-in-springboot/i18n-title.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;本文通过示例说明，在 Springboot 中如何自定义 Valid
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Java" scheme="https://www.tanglei.name/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>大家都知道递归，尾递归呢？什么又是尾递归优化？</title>
    <link href="https://www.tanglei.name/blog/tail-recursive-optimization.html"/>
    <id>https://www.tanglei.name/blog/tail-recursive-optimization.html</id>
    <published>2020-05-03T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.566Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们来聊聊递归函数。为啥突然想到递归？其实就从电影名字《恐怖游轮》《盗梦空间》想到了。</p><h2 id="递归是啥"><a href="#递归是啥" class="headerlink" title="递归是啥"></a>递归是啥</h2><p>递归函数大家肯定写过，学校上课的时候，估计最开始的例子就是斐波拉契数列了吧。例如： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归函数简而言之就是在一个函数中，又“递归”调用自己。在写递归函数的时候，需要注意的地方就是递归函数的结束条件。用递归函数确实能简化很多算法的实现，比如常见的二叉树遍历等。但往往在写递归函数的时候，最容易出现的问题就是所谓的“栈溢出”。</p><p>为什么会有“栈溢出”呢？因为函数调用的过程，都要借助“栈”这种存储结构来保存运行时的一些状态，比如函数调用过程中的变量拷贝，函数调用的地址等等。而“栈”往往存储空间是有限的，当超过其存储空间后，就会抛出著名的异常/错误“StackOverflowError”。</p><p>我们以一个简单的加法为例，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> n + sum(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum(<span class="number">100</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum(<span class="number">1000000</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>很简答，编译运行后，比较小的数字，能得到正确的答案，当数字扩大后，就会直接发生“segmentation fault”。 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(python2<span class="number">.7</span>) ➜  hexo.tanglei.name git:(master) ✗ ./a.out</span><br><span class="line"><span class="number">5050</span></span><br><span class="line">[<span class="number">1</span>]    <span class="number">78159</span> segmentation fault  ./a.out</span><br></pre></td></tr></table></figure><h2 id="尾递归又是啥？"><a href="#尾递归又是啥？" class="headerlink" title="尾递归又是啥？"></a>尾递归又是啥？</h2><p>我得知这个概念，最开始还是因为很多年前一次面试，面试官问我“你知道什么是尾递归吗？”，我以为是“伪”递归，难道是假的递归？？？当初我也是懵逼状态（当初面试官忍住没笑也是厉害了）。从“尾”字可看出来即若函数在尾巴的地方递归调用自己。上面的例子写成尾递归，就变成了如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tailsum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">return</span> tailsum(n<span class="number">-1</span>, sum+n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以试试结果，计算从 1 加到 1000000，仍然是 <code>segmentation fault</code>。为什么呢？ 因为这种写法，本质上还是有多层的函数嵌套调用，中间仍然有压栈、出栈等占用了存储空间（只不过能比前面的方法会省部分空间）。 </p><h2 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h2><p>当你给编译选项开了优化之后，见证奇迹的时刻到了，居然能算出正确结果。如图所示： </p><p><img src="/resources/tail-recursive-optimization/tailrec-cpp.jpg" alt></p><p>原因就是因为编译器帮助做了尾递归优化，可以打开汇编代码看看（这里就不展示 C++的了）。后面我用大家比较熟悉的 JVM based 语言 Scala 来阐述这个优化过程。(好像 Java 的编译器没做这方面的优化，至少我实验我本地 JDK8 是没有的，不清楚最新版本的有木有)（scala 本身提供了一个注解帮助编译器强制校验是否能够进行尾递归优化<code>@tailrec</code>）</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TailRecObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">tailSum</span></span>(n: <span class="type">Int</span>, sum: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> tailSum(n<span class="number">-1</span>, n+sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      println(tailSum(<span class="number">100</span>, <span class="number">0</span>))</span><br><span class="line">      println(tailSum(<span class="number">1000000</span>, <span class="number">0</span>))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下所示，默认情况下 <code>scalac</code> 做了尾递归优化，能够正确计算出结果，当通过 <code>-g:notailcalls</code> 编译参数去掉尾递归优化后，就发生了 <code>Exception in thread &quot;main&quot; java.lang.StackOverflowError</code>了。</p><p><img src="/resources/tail-recursive-optimization/tailrec-scala.jpg" alt></p><p>我们来看看生成的字节码有什么不同。 </p><p><img src="/resources/tail-recursive-optimization/tailrec-scala-opti.jpg" alt="包含尾递归优化的字节码"></p><p><img src="/resources/tail-recursive-optimization/tailrec-scala-no-opti.jpg" alt="不包含尾递归优化的字节码"></p><p>从上面可以看出，尾递归优化后，变成循环了（前面的 C++ 类似）。</p><p>好了，尾递归咱们就了解到这里。个人看法，我们知道有“尾递归”这个点就好了，有时候我们写递归就是为了方便，代码可读性好，如果确实是出于性能考虑，我们可以自己用迭代的方式去实现，不依赖于具体的编译器实现。当然对于像 scala 这样，有一些语法糖能够帮助校验和验证，也是一个不错的选择。但递归转迭代的能力，我们能具备岂不更好。<br>下次想聊什么话题吗？欢迎留言。老规矩，如果有帮助（对你身边的其他人有帮助也行呀，一点帮助也没有也不会看到这里了，哈哈，莫要白嫖），写篇文章真心不容易，希望亲多多帮忙“在看”，转发分享支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天，我们来聊聊递归函数。为啥突然想到递归？其实就从电影名字《恐怖游轮》《盗梦空间》想到了。&lt;/p&gt;
&lt;h2 id=&quot;递归是啥&quot;&gt;&lt;a href=&quot;#递归是啥&quot; class=&quot;headerlink&quot; title=&quot;递归是啥&quot;&gt;&lt;/a&gt;递归是啥&lt;/h2&gt;&lt;p&gt;递归函数大家肯定
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
      <category term="递归" scheme="https://www.tanglei.name/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>一个跨平台的浮点数 bug</title>
    <link href="https://www.tanglei.name/blog/a-bug-relate-with-float-point-cross-platform.html"/>
    <id>https://www.tanglei.name/blog/a-bug-relate-with-float-point-cross-platform.html</id>
    <published>2020-05-01T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.562Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为 6 年前的旧文整理重发，因为最开始是 workdpress 的程序，后改为静态 blog 过程中，导致格式等混乱，这篇<a href="https://www.tanglei.name/blog/a-bug-relate-with-float-point-between-x86-and-x64-in-csharp.html">年久失修旧文可点击访问</a>。</p></blockquote><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>背景就简单点儿说，当初一个项目 C# 编写，涉及浮点运算，来龙去脉省去，直接看如下代码。（为什么有这个问题产生，是因为当初线上产生了很诡异的问题，和本地调试效果不一致。）</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> p3x = <span class="number">80838.0f</span>;</span><br><span class="line"><span class="keyword">float</span> p2y = <span class="number">-2499.0f</span>;</span><br><span class="line"><span class="keyword">double</span> v321 = p3x * p2y;</span><br><span class="line">Console.WriteLine(v321);</span><br></pre></td></tr></table></figure><p>很简单吧，马上笔算下结果为 -202014162，没问题，难道C#没有产生这样的结果？不可能吧，开启 VisualStudio，copy代码试试，果然结果是-202014162。就这样完了么？显然没有！把编译时的选项从AnyCPU改成x64试试~(服务器环境正是64位滴哦！！)结果居然变成了-202014160，对没错，就是-202014160。细想一下，因为浮点运算的误差，-202014160 这个结果是合理的。嗯，再试试C++。// 测试环境Intel(R) i7-3770 CPU, windows OS 64. Visual Studio 2012 默认设置。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> p3x = <span class="number">80838.0f</span>;</span><br><span class="line"><span class="keyword">float</span> p2y = <span class="number">-2499.0f</span>;</span><br><span class="line"><span class="keyword">double</span> v321 = p3x * p2y;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v321 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>呃，好像x86、x64都是这个合理的结果 -202014160。奇了个怪了。其实上面这段C++代码在不同的平台下的结果如下：</p><ul><li>Windows 32/64位下：-202014160</li><li>Linux 64位下（CentOS 6 gcc 4.4.7）：-202014160</li><li>Linux 32位下（Ubuntu 12.04+ gcc 4.6.3）是：-202014162</li></ul><blockquote><p>补充说明：当初这篇文章投稿到酷壳，著名程序员左耳朵耗子那边，这部分结果数据来自耗子叔对文章做的部分调整。（因为当初行文没抓住重点，还引来了不少吐槽）</p></blockquote><p>合理的运算结果，应该是-202014160，正确的运算结果是-202014162，合理性是浮点精度不够造成的（后文解释了合理性）。若是用两个double相乘可得正确且合理的运算结果。// 就别纠结我用的“正确、合理”这两个词是否恰当了。问题是为何C#下X64和X86结果不一致？</p><h2 id="浮点运算结果错误但合理的解释"><a href="#浮点运算结果错误但合理的解释" class="headerlink" title="浮点运算结果错误但合理的解释"></a>浮点运算结果错误但合理的解释</h2><p>为何  80838.0f * -2499.0f = -202014160.0 是合理的？</p><p>32位浮点数在计算机中的表示方式为：1位符号位(s)-8位指数位(E)-23位有效数字(M)，即：</p><p><img src="/resources/a-bug-relate-with-float-point-cross-platform.md/float.webp" alt></p><p>其中E是实际转换成1.xxxxx*2^E的指数，M是去掉 1 后的前面的xxxxx(节约1位)。</p><h3 id="1-80838-0-如何表达？"><a href="#1-80838-0-如何表达？" class="headerlink" title="1.  80838.0 如何表达？"></a>1.  80838.0 如何表达？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80838.0 = 1 0011 1011 1100 0110.0(二进制) = 1.0011 1011 1100 0110 0*2^16</span><br><span class="line">有效位M = 0011 1011 1100 0110 0000 000（一共 23 位）</span><br><span class="line">指数位E = 16 + 127 = 143 = 10001111</span><br><span class="line">内部表示 80838.0 = 0 [10001111] [0011 1011 1100 0110 0000 000] = 0100 0111 1001 1101 1110 0011 0000 0000 = 47 9d e3 00 //实际调试时看到的内存值 可能是00 e3 9d 47是因为调试环境用了小端表示法法：低位字节排内存低地址端，高位排内存高地址</span><br></pre></td></tr></table></figure><h3 id="2-2499-0-如何表达？"><a href="#2-2499-0-如何表达？" class="headerlink" title="2. -2499.0 如何表达？"></a>2. -2499.0 如何表达？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-2499.0 = -100111000011.0 = -1.001110000110 * 2^11</span><br><span class="line">有效位M = 0011 1000 0110 0000 0000 000</span><br><span class="line">指数位E = 11+127=138= 10001010</span><br><span class="line">符号位s = 1</span><br><span class="line">内部表示-2499.0 = 1 [10001010] [0011 1000 0110 0000 0000 000]</span><br><span class="line">=1100 0101 0001 1100 0011 0000 0000 0000 =c5 1c 30 00</span><br></pre></td></tr></table></figure><h3 id="3-如何计算-80838-0-2499-0"><a href="#3-如何计算-80838-0-2499-0" class="headerlink" title="3. 如何计算 80838.0 * -2499.0 = ?"></a>3. 如何计算 80838.0 * -2499.0 = ?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指数 e = 11+16 = 27</span><br><span class="line">则指数位 E = e + 127 = 154 = 10011010</span><br><span class="line">有效位相乘结果为 1.1000 0001 0100 1111 1011 1010 01 （可以自己动手实际算下），实际中只能有23位，后面的被截断即1000 0001 0100 1111 1011 1010 01，相乘结果内部表示=1[10011010][1000 0001 0100 1111 1011 101] = 1100 1101 0100 0000 1010 0111 1101 1101 = cd 40 a7 dd</span><br><span class="line">结果 = -1.1000 0001 0100 1111 1011 101 *2^27</span><br><span class="line">= -11000 0001 0100 1111 1011 1010000</span><br><span class="line">= -202014160</span><br></pre></td></tr></table></figure><p>通过上面得知，32 位浮点数，-202014160 就是合理的结果，完全能解释清楚。但如果有效数字更长的话， 上面的就不会被截断。</p><h3 id="4-正确的结果-202014162怎么得来？"><a href="#4-正确的结果-202014162怎么得来？" class="headerlink" title="4. 正确的结果-202014162怎么得来？"></a>4. 正确的结果-202014162怎么得来？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效位相乘结果为 1.1000 0001 0100 1111 1011 1010 01</span><br><span class="line">即结果 = -1.1000 0001 0100 1111 1011 101001 *2^27</span><br><span class="line">= -11000 0001 0100 1111 1011 101001 = -202014162</span><br></pre></td></tr></table></figure><h2 id="根因挖掘"><a href="#根因挖掘" class="headerlink" title="根因挖掘"></a>根因挖掘</h2><p>上面部分解释了两种结果的来源，但貌似没从根本回到为什么？用C++同样的代码，X86，X64（DEBUG下，这个后面会说）下得到一致的结果-202014160，容易理解且也是合理的。原因何在？看下编译后生成的代码(截取关键部分)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//C# x86 下</span><br><span class="line">......</span><br><span class="line">float p3x = 80838.0f;</span><br><span class="line">0000003b mov dword ptr [ebp-40h],479DE300h</span><br><span class="line">float p2y = -2499.0f;</span><br><span class="line">00000042  mov dword ptr [ebp-44h],0C51C3000h</span><br><span class="line">double v321 = p3x * p2y;</span><br><span class="line">00000049  fld dword ptr [ebp-40h]</span><br><span class="line">0000004c fmul dword ptr [ebp-44h]</span><br><span class="line">0000004f  fstp qword ptr [ebp-4Ch]</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">//C# X64下</span><br><span class="line">......</span><br><span class="line">float p3x = 80838.0f;</span><br><span class="line">00000045  movss xmm0,dword ptr [00000098h]</span><br><span class="line">0000004d  movss dword ptr [rbp+3Ch],xmm0</span><br><span class="line">float p2y = -2499.0f;</span><br><span class="line">00000052  movss xmm0,dword ptr [000000A0h]</span><br><span class="line">0000005a movss dword ptr [rbp+38h],xmm0</span><br><span class="line">double v321 = p3x * p2y;</span><br><span class="line">0000005f  movss xmm0,dword ptr [rbp+38h]</span><br><span class="line">00000064  mulss xmm0,dword ptr [rbp+3Ch]</span><br><span class="line">00000069  cvtss2sd xmm0,xmm0</span><br><span class="line">0000006d  movsd mmword ptr [rbp+30h],xmm0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>C++ x86 / x64下都生成了类似的代码（这也就是为何 C++ x86/x64与C#x64结果一致）即都用了先用浮点乘起来(mulss)，然后转成double(cvtss2sd)。从上面的汇编代码可以看出 C# X86生成代码用的指令fld/fmul/fstp等。其中fld/fmul/fstp等指令是由FPU(float point unit)浮点运算处理器做的，FPU在进行浮点运算时，用了80位的寄存器做相关浮点运算，然后再根据是float/double截取成32位或64位。非FPU的情况是用了SSE中128位寄存器(float实际只用了其中的32位，计算时也是以32位计算的)，这就是导致上述问题产生的最终原因。</p><p>浮点运算标准IEEE-754 推荐标准实现者提供浮点可扩展精度格式(Extended precision)，Intel x86处理器有FPU(float point unit)浮点运算处理器支持这种扩展。C#的浮点是支持该标准的，其中其官方文档也提到了浮点运算可能会产生比返回类型更高精度的值（<strong>正如上面的返回值精度就超过了float的精度</strong>），并说明如果硬件支持可扩展浮点精度的话，那么所有的浮点运算都将用此精度进行以提高效率，举个例子<code>x*y/z, x*y</code>的值可能都在double的能力范围之外了，但真实情况可能除以z后又能把结果拉回到double范围内，这样的话，用了FPU的结果就会得到一个准确的double值，而非FPU的就是无穷大之类的了。</p><p>即产生如上的结果原因是，两个浮点数相乘在非FPU的情况下，用了32位计算产生的结果导致结果存在误差，而FPU是用了80位进行计算的，所以得到的结果是精度很高的，体现在本文的案例上就是个位数上的2。所以大家在写代码的时候得保证实际运行环境/测试环境/开发环境的一致性(包括OS架构啊、编译选项等)啊，不然莫名其妙的问题会产生（本文就是开发环境与运行环境不一致导致的问题，纠结了好久才发现是这个原因）；遇到涉及浮点运算的时候别忘了有可能是这个原因产生的；另外，float/double混用的情况得特别注意。</p><p>总结一下，本文通过分析之前遇到的一个疑难杂症带着大家一块回顾或者学习了一下计算机内部浮点数的表达，解决了疑问。有时候可能需要跟进到硬件底层，当然随着硬件技术的发展，可能以前理所当然的东西在新硬件的情况下也会有所不同（例如文中提到的 FPU 也有更高端的技术来替换了，本人对于硬件这块了解不多，感兴趣可以查阅更多材料，阅读原文有更多参考资料）。</p><p>老规矩，如果有帮助（对你身边的其他人有帮助也行呀），写篇文章不容易，希望亲多多帮忙“在看”，转发分享支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为 6 年前的旧文整理重发，因为最开始是 workdpress 的程序，后改为静态 blog 过程中，导致格式等混乱，这篇&lt;a href=&quot;https://www.tanglei.name/blog/a-bug-relate-with-floa
      
    
    </summary>
    
      <category term="除臭虫" scheme="https://www.tanglei.name/categories/%E9%99%A4%E8%87%AD%E8%99%AB/"/>
    
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
      <category term="除臭虫" scheme="https://www.tanglei.name/tags/%E9%99%A4%E8%87%AD%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>开发规范真的很重要</title>
    <link href="https://www.tanglei.name/blog/simpledateformat-demo-of-alibaba-java-development-manual.html"/>
    <id>https://www.tanglei.name/blog/simpledateformat-demo-of-alibaba-java-development-manual.html</id>
    <published>2020-04-25T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.562Z</updated>
    
    <content type="html"><![CDATA[<p>最近阿里巴巴的 Java 开发手册出了新版（可直接到 <a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">github alibaba-p3c</a> 上获取相关资源哦），我就跟着这个事情说一下我对开发规范的理解吧。 </p><p>提起开发规范，我印象中最深的就是读研究生期间，带我的大牛师兄某导对我的要求。当时是开发一款 B/S 的 3D 渲染引擎，其中 Web 部分由我负责，在大师兄在对我进行 code review 的过程中，对我提出了“严厉”的批评（也一直很感谢他当时的严格要求），原因不是别的，就是我开发的网页中有一部分是文字介绍，里面的标点符号是中英文混用，且代码也不规范，比如缩进不一致、该有的空格没有等等问题。就是从那个时候起，我对代码规范非常重视。这对后来自己写毕业论文等等方面也起到了良好的促进作用，因为导师对这块要求也相对严格。 </p><p>回到代码规范这件事情上，好的代码读起来真的是赏心悦目，当然自己也一直在追求写出好的代码。代码规范中的 code style 只是其中最简单的一种，上述提到的 Java 开发手册也对这部分做出了严格的说明，但实际上能做到的人也不多。按道理，这部分也是最容易做到的一种，因为有模板，直接遵守即可。记得有一部电视剧（叫啥来着？）讲的就是一堆情侣因为纠结到底是用空格还是 tab 键（或者是 Vim 和 Emacs）分手，哈哈这当然是一个笑话。不过在一个 team 里保持统一的代码风格还是有必要的，毕竟你写的代码不是只有你一个人看，在不同的终端，不同的编辑器来讲空格和 tab 可能显示效果都不一样，也就影响了阅读体验。</p><p><img src="/resources/simpledateformat-demo-of-alibaba-java-development-manual/chaoyang-qunzong1.jpg" alt></p><p>对于代码规范来讲，我也希望通过自己的努力去感染身边的人。比如之前在宜信的 hackthon，我就组队发起了一个叫 “code review advisor” 项目，实现的目的其实也很简单，就是让大家在预先统一的规范下编码，如果有违反规范的，直接以 Comment 形式告诉代码提交者需要修改。</p><p><img src="/resources/simpledateformat-demo-of-alibaba-java-development-manual/chaoyang-qunzong2.jpg" alt="hackthon code review advisor截图"></p><p>后来，我到了大疆，又要求 team 同学严格遵守规范，并且使用了一些技术手段完全规范大家提交的代码，对于违反相应规则的代码直接不让提交和打包，当时其实就是利用了 alibaba 对外开源的工具支持。不得不说，还是很佩服阿里巴巴对社区做的相应贡献的。</p><p>现在，我在阿里，发现现实就是规范其实也是一个美好的愿景，因为各种历史等原因，其实大家的代码并没有按照预期的规范去执行和实施。这应该也是普遍的现状吧。就像在其中一次交流会上，孤尽大佬说的那样，美好愿景肯定是需要的，实现她，是需要大家花时间和精力去推进的。</p><p><img src="/resources/simpledateformat-demo-of-alibaba-java-development-manual/java-manual.jpg" alt="孤尽大佬签名版开发手册"></p><p>上图是在那次交流会上，得到孤尽大佬签名版的开发手册（原谅我没文化，认不出）。下面我就以其中的一个例子来说明一下规范的好处。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        String printedDate = simpleDateFormat.format(now);</span><br><span class="line">        System.out.println(printedDate);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Date date = simpleDateFormat.parse(printedDate);</span><br><span class="line">                        System.out.println(simpleDateFormat.format(date));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码片段就是规范中提到的 <code>SimpleDateFormat</code> 使用场景中一个错误的示例，其实就是一个线程安全的问题，跑上面代码片段，预期输出应该是一个正确的字符串表达（例如 <code>2020-04-25 15:41:34</code>），实际过程有可能会抛异常（例如 <code>java.lang.NumberFormatException</code>），也可能会输出一些奇奇怪怪的时间（例如 <code>0015-03-25 15:41:34</code>），这其实都还好，因为毕竟要么异常了，要么“时间不正常”，最要命的是可能会输出一个正确格式的时间，只不过不是预期的，这种问题就相对很难排查了。</p><p>还有比如前面刚跨年的时候各个系统都爆出的时间跨年问题（<code>yyyy</code> 和 <code>YYYY</code> 的问题），在此手册中其实也都有说明。所以，其实类似的规范多多了解更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近阿里巴巴的 Java 开发手册出了新版（可直接到 &lt;a href=&quot;https://github.com/alibaba/p3c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github alibaba-p3c&lt;/a&gt; 上获取相关资源哦），我就跟着这
      
    
    </summary>
    
      <category term="MyLife" scheme="https://www.tanglei.name/categories/MyLife/"/>
    
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>谷歌面经分享</title>
    <link href="https://www.tanglei.name/blog/experience-of-interview-of-google.html"/>
    <id>https://www.tanglei.name/blog/experience-of-interview-of-google.html</id>
    <published>2020-04-19T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.562Z</updated>
    
    <content type="html"><![CDATA[<p>去年换工作的时候, 面试了一下 Google (这里说的是 Google 中国哈), 来了个 Google 面试六轮游, 结果是没通过. 🤣 现在分享下我参加 Google 面试的具体流程以及我觉得应该注意的事项, 希望对大家有帮助. </p><h2 id="相关背景"><a href="#相关背景" class="headerlink" title="相关背景"></a>相关背景</h2><p>先介绍下自己相关背景, 985 本科, Top2 硕士(其实, 大公司都比较看重第一学历的). 在校期间, 科研也没啥能拿得出手的论文. 社招时, 4 年多工作经验, 面试时为大疆后端开发TL(带3~4个人而已). </p><p>Google 整体面试流程上基本如下: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Recruiter Prescreen → </span><br><span class="line">Phone Interview (1~2 sessions) → </span><br><span class="line">Onsite Interview (4~5 sessions, 1 week to receive feedback) → </span><br><span class="line">Hiring Committee Review → </span><br><span class="line">Offer Review → </span><br><span class="line">Offer Delivery (Yippee!)</span><br></pre></td></tr></table></figure><p>我一共经历了 1 轮电话面试, 5 轮 onsite, 如果算上前面的HR 的预筛选的话, 就是 7 轮. </p><h2 id="简历投递"><a href="#简历投递" class="headerlink" title="简历投递"></a>简历投递</h2><p>之前校招其实也参加过, 无奈门槛太高, 竞争压力太大, 连面试流程都木有进. 当初校招时直接网上刷题, 这个网站上其实还能看到往年的一些题目情况: <a href="https://code.google.com/codejam/past-contests" target="_blank" rel="noopener">Google Code Jam</a>.  基本上分几轮, 每轮 top xx 的选手有机会进入面试. </p><p>第一次换工作的时候, 其实也有找在 Google 的同学内推, 填了不少内推推荐理由呀等等, 最后简历都没过. 😿 当然, 简历没过肯定也有多种理由啦, 这个其实跟各个公司都一样. 比如人家需求是招聘 P7, 以你的工作年限经验等最多就 P6, 肯定不行; 还有比如希望是招聘机器学习等相关经验的等等, 岗位信息等不匹配也不行; 当然还有一种, 岗位描述等都相关, 确实简历没啥亮点, 太平庸, 也直接被 HR 给筛选掉了. </p><p>这次其实刚开始是没有考虑过面 Google 的, 机缘巧合在 linkedin 在有 Google 的 HR 联系, 说要不要试试 Google 的机会. 当然就抱着 “试试就试试” 的想法跟进面试流程啦. </p><p>既然要尝试, 当然还是需要认真对待, 修改简历.  防止手生, 肯定需要提前准备”刷题”的.  发简历给HR 小姐姐后, HR 小姐姐会给你一些准备材料供你参考, 这份材料还相对比较丰富, 直接会告诉你面试涉及到的知识点, 推荐书籍还有一些推荐参考的视频等. <strong>需要的小伙伴可以留言, 我整理下发给你</strong>(跟 HR 求证过, 这些资料是可以公开分享的哈).</p><p>其实, 时间有限, “刷题”准备不够, 当初预感估计面试面不下来. 不过真正走完所有面试流程, 发现其实面试题目没有想象中的<strong>那么</strong>难(然而, 我仍然没有过), 积极准备, 还是有希望的. </p><p>因为面试题目比较敏感, 不能直接分享原题哈, 不过我会根据我的理解, 找类似知识点和类似难度的题目分享一下. </p><h2 id="HR-面试"><a href="#HR-面试" class="headerlink" title="HR 面试"></a>HR 面试</h2><p>对, 第一轮就是 HR 面试, 上面流程中的 “Recruiter Prescreen”, 其实就是一些计算机相关基础的填空题和选择题. 几分钟的时间, 十几道题目. 面试过程中, 不需要给予明确的解释, 知道就是知道, 不知道就不知道.  题目可能会涉及到比如: 快排的时间复杂度是多少? 选择排序是稳定的排序算法吗? 等等之类的. </p><p>这也是我参与的所有面试当中, HR 直接参与的”技术”面的. 我理解就通过这一轮面试可以用比较少的成本把一些不合适的候选人直接排除了. 当然这种方法可能不一定适用于所有公司. </p><h2 id="电话面试"><a href="#电话面试" class="headerlink" title="电话面试"></a>电话面试</h2><p>电话面试要求直接用 Google doc 共享写代码, 需要要求你有一个稳定的网络环境.  这轮面试我理解应该不会太难, 从我面试的经验来看也确实如此.  </p><p>相比 onsite, 电话面试不能在一个很好的沟通环境下, 不能面对面和面试官进行交流. 当初我面试的一道题目和二叉树的遍历相关, 当然题目不会是直接写二叉树的先序/中序/后序/层次之类的遍历, 会有一个具体的业务场景在里边. 需要你分析这个具体的业务场景, 能够抽象出题目本质上就是 二叉树的遍历方法.  这道题目算是拿下了. 实际 coding 后, 面试官可能会根据你写的 code 去提问, 一些边界条件以及让你提优化方案. </p><p>HR 小姐姐介绍的电话面试时 1-2 轮, 其实我理解, 这应该是需要看第一轮的面试官的反馈, 是否犹豫是否再安排一轮电话面试. 毕竟和 onsite 相比, 电话面试成本相对更低一些. </p><p>在线 code 其实在面试过程中, 还是蛮重要的环节. 从你 code 的细节, 包括 code style, 边界条件的判断, 哪怕是注释情况, 都能看出一些编程习惯.  我认为这个环节对于招聘一个写代码的工程师来说, 肯定是一个必不可少的环节(google 整个就搞了五六轮). </p><h2 id="onsite"><a href="#onsite" class="headerlink" title="onsite"></a>onsite</h2><p>电话面试通过后, HR 会很快跟你反馈沟通面试结果, 是否通过, 以及 onsite 的安排.  因为 onsite 是 4-5 轮, 1 轮一小时的话, 需要 4-5 个小时, 其实还是蛮耗费精力的. 一般会沟通可以约 2 个半天或者 1 整天, 两个半天的好处是, 时间不会那么紧张, 前两轮后, 中途可以过几天再休整调整下再继续. 我当初就选择”快刀斩乱麻” 或者 “早死早超生” 的想法直接约了 1 天搞定. </p><p><img src="https://www.tanglei.name/resources/experience-of-interview-of-google/google-guest.jpg" alt></p><p>onsite 也基本上是在电脑上 coding. 你和面试官一人一个笔记本, code 时共享屏幕, 有时候题目面试官会在白板上写出.  onsite 的题目, 明显就要比电话面试的题目难度高一些呢. 但实际上比我想象中的要简单些. 因为曾经想 Google 这样的公司面试恐怕连理解题目意思都要理解大半天吧. 可能也是社招的缘故, 社招整体感觉在算法的要求比校招就要低一些. 这只是我的主观感受啦.  (确实自己在当面试官的过程中, 在算法这块对社招的同学预期也会低一些)</p><p>我记得其中有一道题目就跟 leetcode 上的类似(再次声明不是原题, 也不 share 原题), leetcode 上那个题目应该是二维矩阵, 最短路径相关的. 用 dp 可以解决. 只不过, 一般题目会分为好几个小问题, 难度一般从易到难. </p><p>同时也考察到了二叉树, 仍然围绕着二叉树的遍历进行. 需要熟知二叉树的各种遍历方式, 非递归的方法(递归比较容易, 一般不会让写这个). 在遇到二叉树相关问题的时候, 是否可以联想到二叉树的遍历上来. </p><p>另外有一道系统设计的问题, “知识图谱”的概念, 围绕着”图”的相关算法, 这个要求在白板上写出设计方案和伪代码. 同时面试官会不断 push 你让你提出更优的解决方案. 有足够多的计算资源, 并行去跑, 以及具体怎么实现.  这道题目我回答的不好(当初也知道不好, 后面 HR 反馈也印证了这一点). </p><p>还有一道题目, 是解决生活中的场景题目. 需要你抽象出这个问题, 用代码来解决. 一般这种题目, 就需要反复跟面试官去沟通和确认其中的场景, 怎样把业务抽象成算法.  记得之前面试 Amazon 的时候也有类似的题目(只不过当初面 Amazon 考察的是 OO Design, 而本题是具体算法实现). </p><p>onsite 一共聊了 5 轮, 上午 2 轮, 下午 3 轮, 其中有两轮是英文面试(英文面试后面会说). </p><p>整体来说,工程师岗位面试会围绕如下几个方面进行(以下参考 HR 提供的面试指南): </p><ul><li>Coding: 用熟悉的编程语言(不限)实现给定的题目. 会重点关注解题目过程中的理解和沟通能力;</li><li>算法: 涉及到 排序/搜索/分治/动态规划/贪心/递归, 具体数据结构, 以及也有可能会涉及到 <code>Dijkstra</code> 和 <code>A*</code> 等算法, 需要会算法复杂度的分析;</li><li>排序: 常见的排序算法, 时间/空间复杂度, 例如 快排/归并/堆排序/插入/基数排序等等;</li><li>数据结构: 数组/连表/堆/栈/hash/数/二叉树等;</li><li>数学: 可能会涉及到离散数学, 组合数学, 例如 N个中选k 个的方法等;</li><li>图: 图的表达(例如矩阵/邻接表), bfs/dfs 等;</li><li>递归: 递归和迭代的转换; </li><li>其他: 设计和操作系统等;</li></ul><p>以上这部分摘自 HR 提供的 <code>Google 工程师面试指南.pdf</code>, 有需要的同学(已和 HR 确认, 此资料可共享), 从公众号后台回复 “Google面试指南+邮箱”, 我会发送给你(或者直接扫码加我微信也可以). </p><h2 id="吃饭"><a href="#吃饭" class="headerlink" title="吃饭"></a>吃饭</h2><p><img src="https://www.tanglei.name/resources/experience-of-interview-of-google/eat-at-google.jpg" alt="Google 食堂"></p><p>中午 HR 小姐姐会安排一个 Google 的工程师, 带你吃饭, 跟你聊天. 有任何疑问都可以跟他沟通.  不得不说, Google 的伙食还是蛮不错的. </p><p>我当初就跟小哥哥聊了下他在 Google 工作的感受. </p><h2 id="英文面试"><a href="#英文面试" class="headerlink" title="英文面试"></a>英文面试</h2><p>英文面试, 单独拿出来说一下, Google 中国这边, 有 1-2 轮. 建议还是提前准备一下, 练习一下基本的口语. 不要因为面试过程中, 突然让你只用英语沟通, 让气氛变得紧张起来, 导致发挥不好.  自我介绍之类的肯定你可以提前准备, 然后就是你可以尝试比如拿其中的题目自己模拟一下面试场景. 主要是可能需要提前熟悉一下基本的计算机相关词汇, 不要到时候想表达确表达不出. </p><p>整体来说, Google 的面试确实很难, 但确实也没我想象中的那么难. 但要求确实是很高的, 基本上一些边界 case 等也都是在考察范围内的. onsite 面试完后, 在第二天, 我就得到结果通知, 面试没通过.  事实来看没通过的结果反馈比通过反馈更快. HR 会反馈你哪里表现得不够好, 然后如果想进 Google, 就加油刷题, 说 1 年后, 可以再次尝试, 保持联系哦. </p><p>哈哈, 以上就是我这次完整的 Google 面试之旅, 虽然失败(实力还不够)了, 但还是有收获的. 如果大家有足够自信(当然也要有一定实力哈), 也可以找我帮忙内推, 我可以给在 Google 的同学帮忙或者直接给招聘的 HR 同学. ​如果要面试 Google, 刷题是在所难免的了. 整体来讲, Google 的面试体验还是很不错的, 全程 HR 小姐姐悉心指导和及时反馈, 给 HR 小姐姐点赞 ​</p><p>如果大家觉得这篇文章有所收获, 还希望大家帮忙分享, 转发 和 “在看”. 感谢! </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年换工作的时候, 面试了一下 Google (这里说的是 Google 中国哈), 来了个 Google 面试六轮游, 结果是没通过. 🤣 现在分享下我参加 Google 面试的具体流程以及我觉得应该注意的事项, 希望对大家有帮助. &lt;/p&gt;
&lt;h2 id=&quot;相关背景&quot;
      
    
    </summary>
    
      <category term="经验技巧" scheme="https://www.tanglei.name/categories/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Google" scheme="https://www.tanglei.name/tags/Google/"/>
    
      <category term="面试" scheme="https://www.tanglei.name/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="MyLife" scheme="https://www.tanglei.name/tags/MyLife/"/>
    
  </entry>
  
  <entry>
    <title>这里有一个慢 SQL 查询等你来优化</title>
    <link href="https://www.tanglei.name/blog/slow-sql-optimazation-of-explain-extended.html"/>
    <id>https://www.tanglei.name/blog/slow-sql-optimazation-of-explain-extended.html</id>
    <published>2020-04-11T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近工作上遇到一个”神奇”的问题, 或许对大家有帮助, 因此形成本文.</p><p><img src="/resources/slow-sql-optimazation-of-explain-extended/wtf-confused.jpeg" alt></p><p>问题大概是, 我有两个表 TableA, TableB, 其中 TableA 表大概百万行级别(存量业务数据), TableB 表几行(新业务场景, 数据还未膨胀起来), 语义上  <code>TableA.columnA = TableB.columnA</code>, 其中 <code>columnA</code> 上建立了索引, 但查询的时候确巨慢无比, 基本上到 5-6 秒, 明显跟预期不符合.  </p><p>下面我以一个具体的例子来说明吧, 模拟其中的 SQL 查询场景. </p><h3 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h3><ul><li><code>user_info</code> 表, 为了场景尽量简单, 我只 mock 了其中的三列数据. </li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc user_info;</span><br><span class="line">+<span class="comment">-------+--------------+------+-----+---------+----------------+</span></span><br><span class="line">| Field | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+<span class="comment">-------+--------------+------+-----+---------+----------------+</span></span><br><span class="line">| id    | int(11)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| uid   | varchar(64)  | NO   | MUL | NULL    |                |</span><br><span class="line">| name  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">+<span class="comment">-------+--------------+------+-----+---------+----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- `</span>user_score<span class="string">` 表, 其中 `</span>uid<span class="string">` 和 `</span>user_info.uid<span class="string">` 语义一致:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">sql</span></span><br><span class="line">mysql&gt; <span class="keyword">desc</span> user_info;</span><br><span class="line">+<span class="comment">-------+--------------+------+-----+---------+----------------+</span></span><br><span class="line">| Field | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+<span class="comment">-------+--------------+------+-----+---------+----------------+</span></span><br><span class="line">| id    | int(11)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| uid   | varchar(64)  | NO   | MUL | NULL    |                |</span><br><span class="line">| name  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">+<span class="comment">-------+--------------+------+-----+---------+----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>其中数据情况如下, 都是很常见的场景. </li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from user_score limit 2;</span><br><span class="line">+<span class="comment">----+--------------------------------------+-------+</span></span><br><span class="line">| id | uid                                  | score |</span><br><span class="line">+<span class="comment">----+--------------------------------------+-------+</span></span><br><span class="line">|  5 | 111111111                            |   100 |</span><br><span class="line">|  6 | 55116d58-be26-4eb7-8f7e-bd2d49fbb968 |   100 |</span><br><span class="line">+<span class="comment">----+--------------------------------------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> user_info <span class="keyword">limit</span> <span class="number">2</span>;</span><br><span class="line">+<span class="comment">----+--------------------------------------+-------------+</span></span><br><span class="line">| id | uid                                  | name        |</span><br><span class="line">+<span class="comment">----+--------------------------------------+-------------+</span></span><br><span class="line">|  1 | 111111111                            | tanglei     |</span><br><span class="line">|  2 | 55116d58-be26-4eb7-8f7e-bd2d49fbb968 | hudsonemily |</span><br><span class="line">+<span class="comment">----+--------------------------------------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> user_score</span><br><span class="line">    -&gt; <span class="keyword">union</span></span><br><span class="line">    -&gt; <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> user_info;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        4 |</span><br><span class="line">|  3000003 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">1.39</span> sec)</span><br></pre></td></tr></table></figure><ul><li>索引情况是: </li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show index from user_score;</span><br><span class="line">+<span class="comment">------------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line">| Table      | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | <span class="keyword">Comment</span> | Index_comment |</span><br><span class="line">+<span class="comment">------------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line">| user_score |          <span class="number">0</span> | PRIMARY   |            <span class="number">1</span> | <span class="keyword">id</span>          | A         |           <span class="number">4</span> |     <span class="literal">NULL</span> | <span class="literal">NULL</span>   |      | BTREE      |         |               |</span><br><span class="line">| user_score |          <span class="number">1</span> | index_uid |            <span class="number">1</span> | uid         | A         |           <span class="number">4</span> |     <span class="literal">NULL</span> | <span class="literal">NULL</span>   | YES  | BTREE      |         |               |</span><br><span class="line">+<span class="comment">------------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> user_info;</span><br><span class="line">+<span class="comment">-----------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line">| Table     | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | <span class="keyword">Comment</span> | Index_comment |</span><br><span class="line">+<span class="comment">-----------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line">| user_info |          <span class="number">0</span> | PRIMARY   |            <span class="number">1</span> | <span class="keyword">id</span>          | A         |     <span class="number">2989934</span> |     <span class="literal">NULL</span> | <span class="literal">NULL</span>   |      | BTREE      |         |               |</span><br><span class="line">| user_info |          <span class="number">1</span> | index_uid |            <span class="number">1</span> | uid         | A         |     <span class="number">2989934</span> |     <span class="literal">NULL</span> | <span class="literal">NULL</span>   |      | BTREE      |         |               |</span><br><span class="line">+<span class="comment">-----------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>查询业务场景: 已知 <code>user_score.id</code>, 需要关联查询对应<code>user_info</code>的信息, (大家先忽略这个具体业务场景是否合理哈). 那么对应的 SQL 很自然的如下: </li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from user_score us</span><br><span class="line">    -&gt; inner join user_info ui on us.uid = ui.uid</span><br><span class="line">    -&gt; where us.id = 5;</span><br><span class="line">+<span class="comment">----+-----------+-------+---------+-----------+---------+</span></span><br><span class="line">| id | uid       | score | id      | uid       | name    |</span><br><span class="line">+<span class="comment">----+-----------+-------+---------+-----------+---------+</span></span><br><span class="line">|  5 | 111111111 |   100 |       1 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685399 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685400 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685401 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685402 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685403 | 111111111 | tanglei |</span><br><span class="line">+<span class="comment">----+-----------+-------+---------+-----------+---------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">1.18</span> sec)</span><br></pre></td></tr></table></figure><p>请忽略其中的数据, 我刚开始 mock 了 100W, 然后又重复导入了两遍, 因此数据有一些重复.  300W 数据, 最后查询出来也是 1.18 秒. 按道理应该更快的. 老规矩 <code>explain</code> 看看啥情况?</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain</span><br><span class="line">    -&gt; select * from user_score us</span><br><span class="line">    -&gt; inner join user_info ui on us.uid = ui.uid</span><br><span class="line">    -&gt; where us.id = 5;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+-------------------+---------+---------+-------+---------+-------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys     | key     | key_len | ref   | rows    | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+-------------------+---------+---------+-------+---------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | us    | const | PRIMARY,index_uid | PRIMARY | 4       | const |       1 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | ui    | ALL   | NULL              | NULL    | NULL    | NULL  | 2989934 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+-------------------+---------+---------+-------+---------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>发现 <code>user_info</code>表没用上索引, 全表扫描近 300W 数据? 现象是这样, 为什么呢? </p><p>你不妨思考一下, 如果你遇到这种场景, 应该怎么去排查? </p><hr><p>我当时也是”一顿操作猛如虎”, 然并卵? 尝试了什么多种 sql 写法来完成这个操作.</p><p>比如更换Join表的顺序(驱动表/被驱动表)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info ui inner join user_score us on us.uid = ui.uid where us.id = 5;</span><br><span class="line">+----+-------------+-------+-------+-------------------+---------+---------+-------+---------+-------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys     | key     | key_len | ref   | rows    | Extra       |</span><br><span class="line">+----+-------------+-------+-------+-------------------+---------+---------+-------+---------+-------------+</span><br><span class="line">|  1 | SIMPLE      | us    | const | PRIMARY,index_uid | PRIMARY | 4       | const |       1 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | ui    | ALL   | NULL              | NULL    | NULL    | NULL  | 2989934 | Using where |</span><br><span class="line">+----+-------------+-------+-------+-------------------+---------+---------+-------+---------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>再比如用子查询: </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where uid in  (select uid from user_score where id = 5);</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+-------------------+---------+---------+-------+---------+-------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys     | key     | key_len | ref   | rows    | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+-------------------+---------+---------+-------+---------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_score | const | PRIMARY,index_uid | PRIMARY | 4       | const |       1 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | user_info  | ALL   | NULL              | NULL    | NULL    | NULL  | 2989934 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+------------+-------+-------------------+---------+---------+-------+---------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>最终, 还是没有结果. 但直接单表查询写 SQL 确能用上索引. </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from user_info where uid = '111111111';</span><br><span class="line">+<span class="comment">---------+-----------+---------+</span></span><br><span class="line">| id      | uid       | name    |</span><br><span class="line">+<span class="comment">---------+-----------+---------+</span></span><br><span class="line">|       1 | 111111111 | tanglei |</span><br><span class="line">| 3685399 | 111111111 | tanglei |</span><br><span class="line">| 3685400 | 111111111 | tanglei |</span><br><span class="line">| 3685401 | 111111111 | tanglei |</span><br><span class="line">| 3685402 | 111111111 | tanglei |</span><br><span class="line">| 3685403 | 111111111 | tanglei |</span><br><span class="line">+<span class="comment">---------+-----------+---------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> user_info <span class="keyword">where</span> uid = <span class="string">'111111111'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+-----------+---------+-------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table     | type | possible_keys | key       | key_len | ref   | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+-----------+---------+-------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user_info | ref  | index_uid     | index_uid | 194     | const |    6 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+-----------+---------+-------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><img src="/resources/slow-sql-optimazation-of-explain-extended/confused.jpeg" alt></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>尝试更换检索条件, 比如更换 uid 直接关联查询, 索引仍然用不上, 差点放弃了都. 在准备求助 DBA 前, 看了下表的建表语句. </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table user_info;</span><br><span class="line">+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table     | Create Table                                                                                                                                                                                                                                                 |</span><br><span class="line">+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| user_info | CREATE TABLE `user_info` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `uid` varchar(64) NOT NULL,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `index_uid` (`uid`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3685404 DEFAULT CHARSET=utf8 |</span><br><span class="line">+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show create table user_score;</span><br><span class="line">+------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table      | Create Table                                                                                                                                                                                                                             |</span><br><span class="line">+------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| user_score | CREATE TABLE `user_score` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `uid` varchar(64) NOT NULL,</span><br><span class="line">  `score` float DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `index_uid` (`uid`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 |</span><br><span class="line">+------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>完全有理由怀疑因为字符集不一致的问题导致索引失效的问题了.<br>于是修改了小表(真实线上环境可别乱操作)的字符集与大表一致, 再测试下. </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from user_score us</span><br><span class="line">    -&gt; inner join user_info ui on us.uid = ui.uid</span><br><span class="line">    -&gt; where us.id = 5;</span><br><span class="line">+<span class="comment">----+-----------+-------+---------+-----------+---------+</span></span><br><span class="line">| id | uid       | score | id      | uid       | name    |</span><br><span class="line">+<span class="comment">----+-----------+-------+---------+-----------+---------+</span></span><br><span class="line">|  5 | 111111111 |   100 |       1 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685399 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685400 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685401 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685402 | 111111111 | tanglei |</span><br><span class="line">|  5 | 111111111 |   100 | 3685403 | 111111111 | tanglei |</span><br><span class="line">+<span class="comment">----+-----------+-------+---------+-----------+---------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span></span><br><span class="line">    -&gt; <span class="keyword">select</span> * <span class="keyword">from</span> user_score us</span><br><span class="line">    -&gt; <span class="keyword">inner</span> <span class="keyword">join</span> user_info ui <span class="keyword">on</span> us.uid = ui.uid</span><br><span class="line">    -&gt; <span class="keyword">where</span> us.id = <span class="number">5</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+-------------------+-----------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys     | key       | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+-------------------+-----------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | us    | const | PRIMARY,index_uid | PRIMARY   | 4       | const |    1 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | ui    | ref   | index_uid         | index_uid | 194     | const |    6 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+-------------------+-----------+---------+-------+------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>果然 work 了. </p><h3 id="挖掘根因"><a href="#挖掘根因" class="headerlink" title="挖掘根因"></a>挖掘根因</h3><p>其实深究原因, 就是网上各种 MySQL军规/规约所提到的, “索引列不要参与计算”.  这次这个 case, 如果知道 <code>explain extended + show warnings</code> 这个工具的话, (以前都不知道<code>explain</code>后面还能加 <code>extended</code> 参数), 可能就尽早”恍然大悟”了. (最新的 MySQL 8.0版本貌似不需要另外加这个关键字). </p><p>看下效果. (啊, 我还得把字符集改回去!!!)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain extended select * from user_score us  inner join user_info ui on us.uid = ui.uid where us.id = 5;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+-------------------+---------+---------+-------+---------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys     | key     | key_len | ref   | rows    | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+-------------------+---------+---------+-------+---------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | us    | const | PRIMARY,index_uid | PRIMARY | 4       | const |       1 |   100.00 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | ui    | ALL   | NULL              | NULL    | NULL    | NULL  | 2989934 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+-------------------+---------+---------+-------+---------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">warnings</span>;</span><br><span class="line">+<span class="comment">-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Level | Code | Message                                                                                                                                                                                                                                                                              |</span><br><span class="line">+<span class="comment">-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Note  | 1003 | <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">'5'</span> <span class="keyword">AS</span> <span class="string">`id`</span>,<span class="string">'111111111'</span> <span class="keyword">AS</span> <span class="string">`uid`</span>,<span class="string">'100'</span> <span class="keyword">AS</span> <span class="string">`score`</span>,<span class="string">`test`</span>.<span class="string">`ui`</span>.<span class="string">`id`</span> <span class="keyword">AS</span> <span class="string">`id`</span>,<span class="string">`test`</span>.<span class="string">`ui`</span>.<span class="string">`uid`</span> <span class="keyword">AS</span> <span class="string">`uid`</span>,<span class="string">`test`</span>.<span class="string">`ui`</span>.<span class="string">`name`</span> <span class="keyword">AS</span> <span class="string">`name`</span> <span class="keyword">from</span> <span class="string">`test`</span>.<span class="string">`user_score`</span> <span class="string">`us`</span> <span class="keyword">join</span> <span class="string">`test`</span>.<span class="string">`user_info`</span> <span class="string">`ui`</span> <span class="keyword">where</span> ((<span class="string">'111111111'</span> = <span class="keyword">convert</span>(<span class="string">`test`</span>.<span class="string">`ui`</span>.<span class="string">`uid`</span> <span class="keyword">using</span> utf8mb4))) |</span><br><span class="line">+<span class="comment">-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>索引列参与计算了, 每次都要根据字符集去转换, 全表扫描, 你说能快得起来么? </p><p>至于这个问题为什么会发生? 综合来看, 就是因为历史原因, 老业务场景中的原表是假 <code>utf8</code>, 新业务新表采用了真 <code>utf8mb4</code>. </p><ol><li>考虑新表的时候, 忽略和原库字符集的比较. 其实, 发现库里面的不同表可能都有不同的字符集, 不同人建的时候可能都依据个人喜好去选择了不同的字符集. 由此可见, <strong>开发规范有多重要</strong>. </li><li>虽然知道索引列不能参与计算, 但这个场景下都是相同的类型,  <code>varchar(64)</code> 最终查询过程中仍然发生了类型转换. 因此需要把字段字符集不一致等同于字段类型不一致.</li><li>如果这个 case, 利用 <code>fail-fast</code> 的理念的话, 发现不一致, 直接不让 join 会不会更好? (就像 <code>char v.s varchar</code> 不能 join 一样). </li></ol><h3 id="留一道思考题"><a href="#留一道思考题" class="headerlink" title="留一道思考题"></a>留一道思考题</h3><p>你能解释如下情况吗? 查询结果表现为何不一致? 注意一下 SQL 的执行顺序, 查询优化器工作流程, 以及其中的 <strong>Using join buffer (Block Nested Loop)</strong>, 建议多看看 <a href="https://dev.mysql.com/doc/refman/5.6/en/" target="_blank" rel="noopener">MySQL 官方手册</a> 深入背后原理.  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from user_info ui</span><br><span class="line">    -&gt; inner join user_score us on us.uid = ui.uid</span><br><span class="line">    -&gt; where us.uid = '111111111';</span><br><span class="line">+<span class="comment">---------+-----------+---------+----+-----------+-------+</span></span><br><span class="line">| id      | uid       | name    | id | uid       | score |</span><br><span class="line">+<span class="comment">---------+-----------+---------+----+-----------+-------+</span></span><br><span class="line">|       1 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685399 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685400 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685401 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685402 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685403 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">+<span class="comment">---------+-----------+---------+----+-----------+-------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">1.14</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> user_info ui</span><br><span class="line">    -&gt; <span class="keyword">inner</span> <span class="keyword">join</span> user_score us <span class="keyword">on</span> us.uid = ui.uid</span><br><span class="line">    -&gt; <span class="keyword">where</span> ui.uid = <span class="string">'111111111'</span>;</span><br><span class="line">+<span class="comment">---------+-----------+---------+----+-----------+-------+</span></span><br><span class="line">| id      | uid       | name    | id | uid       | score |</span><br><span class="line">+<span class="comment">---------+-----------+---------+----+-----------+-------+</span></span><br><span class="line">|       1 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685399 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685400 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685401 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685402 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">| 3685403 | 111111111 | tanglei |  5 | 111111111 |   100 |</span><br><span class="line">+<span class="comment">---------+-----------+---------+----+-----------+-------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain</span><br><span class="line">    -&gt; select * from user_info ui</span><br><span class="line">    -&gt; inner join user_score us on us.uid = ui.uid</span><br><span class="line">    -&gt; where us.uid = '111111111';</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+-----------+---------+-------+---------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key       | key_len | ref   | rows    | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+-----------+---------+-------+---------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | us    | ref  | index_uid     | index_uid | 258     | const |       1 | Using index condition                              |</span><br><span class="line">|  1 | SIMPLE      | ui    | ALL  | NULL          | NULL      | NULL    | NULL  | 2989934 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+-----------+---------+-------+---------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span></span><br><span class="line">    -&gt; <span class="keyword">select</span> * <span class="keyword">from</span> user_info ui</span><br><span class="line">    -&gt; <span class="keyword">inner</span> <span class="keyword">join</span> user_score us <span class="keyword">on</span> us.uid = ui.uid</span><br><span class="line">    -&gt; <span class="keyword">where</span> ui.uid = <span class="string">'111111111'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+-----------+---------+-------+------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key       | key_len | ref   | rows | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+-----------+---------+-------+------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | ui    | ref  | index_uid     | index_uid | 194     | const |    6 | Using index condition                              |</span><br><span class="line">|  1 | SIMPLE      | us    | ALL  | index_uid     | NULL      | NULL    | NULL  |    4 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+-----------+---------+-------+------+----------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>说明: 本文测试场景基于 MySQL 5.6, 另外, 本文案例只是为了说明问题, 其中的 SQL 并不规范(例如尽量别用 select * 之类的), 请勿模仿(模仿了我也不负责)​.  为了写本文, 可花了不少时间, 建 DB, 灌mock数据等等, 如果觉得有用, 还望你帮忙”在看”, “转发”. 最后留一个思考题供讨论, 欢迎留言说出你的看法. </p><h3 id="打个广告"><a href="#打个广告" class="headerlink" title="打个广告"></a>打个广告</h3><p>阿里云ECS弹性计算服务是阿里云的最重要的云服务产品之一。弹性计算服务是一种简单高效，处理能力可弹性伸缩的计算服务。我们始终致力于利用和创造业界最新的前沿技术，让更多的客户轻松享受这些技术红利，在云上快速构建更稳定、安全的应用，提升运维效率，降低IT成本，使客户更专注于自己的核心业务创新。弹性计算重新定义了人们使用计算资源的方式，这一新的方式正在并且将一直影响着关于计算资源的生态和经济圈。我们正在创造历史，我们真诚地邀请您加入我们的队伍。</p><p>最近团队释放不少 HC, 诚招 P6/P7/P8 的同学, 本组同学主要招聘后端研发同学(<a href="https://mp.weixin.qq.com/s/RZMUWZMIuFLjtjW4MSi-0A" target="_blank" rel="noopener">JD在此</a>), 感兴趣的同学可扫描下面二维码加我联系. </p><p>另外, 2021 届校招/实习生岗位也正在进行中(<a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;mid=2247483874&amp;idx=1&amp;sn=8235b99bf33d1442a486834cdb58023f&amp;chksm=eb470006dc3089102c8e76a9ee38498354cc7995c3b6cdb0b2489c9c90a7b990401a380f241c&amp;token=505611704&amp;lang=zh_CN#rd" target="_blank" rel="noopener">详情请戳</a>), 如果你是 2020-11 – 2021-07 月之间毕业, 同时对阿里巴巴感兴趣, 也欢迎联系我帮忙内推. </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/explain-extended.html" target="_blank" rel="noopener">explain-extended 文档</a></li><li><a href="https://faker.readthedocs.io/en/master/index.html#" target="_blank" rel="noopener">mock数据生成器</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/bnl-bka-optimization.html" target="_blank" rel="noopener">Block Nested-Loop and Batched Key Access Joins</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近工作上遇到一个”神奇”的问题, 或许对大家有帮助, 因此形成本文.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/resources/slow-s
      
    
    </summary>
    
      <category term="工作那些事儿" scheme="https://www.tanglei.name/categories/%E5%B7%A5%E4%BD%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
      <category term="经验技巧" scheme="https://www.tanglei.name/tags/%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7/"/>
    
      <category term="MySQL" scheme="https://www.tanglei.name/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>2019年终总结</title>
    <link href="https://www.tanglei.name/blog/summary-of-year-2019.html"/>
    <id>https://www.tanglei.name/blog/summary-of-year-2019.html</id>
    <published>2020-02-08T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.562Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>还是按照往年一样, 年终总结总是拖, 19年的比18年的总结相比, 出的时间差不多.</p></blockquote><p>先看看 <a href="https://www.tanglei.name/blog/summary-of-year-2018.html">去年立下的 Flag</a> 怎么样~ </p><ul><li>降点体重 —&gt; 失败 😭 不降反增了. 只能把这个 flag 延续到今年了. </li><li>汽车摇号 —-&gt; 这个没啥说的, 继续吧.</li><li>技术上能有进步 —&gt; 应该还是有的吧(说起来怎么感觉有点心虚), 我换了工作了, 从偏向业务领域往底层平台方向走了. 目前在阿里云弹性计算. 对阿里云感兴趣的同学欢迎私聊. </li><li>老家的🏡 —&gt; 这个解决了. 在走相关流程的时候, 才发现偏远山区和一线城市的服务以及质量效率, 办公人员的素质等等还是有不少差距的. 我想这也是很多人努力往一线/中心城市去靠近的愿意之一吧. </li></ul><p>再具体说说工作上的吧. 我从 17 年 9 月入职大疆, 到离开大疆 差不多 2 年整的时间吧, 不算长也不短了. 在大疆主要做 <a href="https://www.skypixel.com/" target="_blank" rel="noopener">天空之城</a> 航拍社区, 还是有不少收获的. 因种种原因, 后来加入了阿里云弹性计算团队. 万万没想到, <a href="https://www.tanglei.name/blog/the-first-accepted-offer-in-life.html">校招</a>时曾经拒过阿里offer的我, 在四五年后最终还是来了阿里. 在大疆也算基本上完成了自己的使命吧. 因为在大疆使用了各种云服务云产品, 也是因为在大疆的工作才对阿里云有一些了解, 没想到最终从甲方变为乙方(之前在大疆通过钉钉和阿里云同学撕逼现在确成了被撕逼的对象). 之前都在围绕着上层业务做一些开发, 目前换了方向偏向于 ECS / 物理机自动化运维 等等, 给自己的技术深度和广度都扩展一些吧.  </p><p>也感谢大疆, 让我接触了一些技术管理工作, 算是真正意义上的一些”管理”吧, 除了开发之间的合作, 工作的分配, 方案设计, 进度把控等, 另外还有一个比较重要的绩效考核. 其实绩效考核不是一件容易的事情, 怎样更好的做到公平公正更是一门艺术. 一个人的力量始终有限, 你有技术的同时, 还需要让团队进步, 共同创造价值, 很多事情不仅仅需要你会, 你能处理, 而是要把你的这部分能力传承给大家, 让之前只有你能做的事情现在其他人也都能做. 这样, 你才能抽出更多的时间和经历去考虑更多的事情.  当然我在管理方面懂得还是太少, 我觉得我目前还是需要先把自己的技术基础打牢, 再有所沉淀, 至于管理不管理就再说吧.  我最后选择到了阿里云, 纯一线开发.  </p><p>阿里云在国内还算顶尖的, 但放眼全球, 总体来说离 AWS 还是有一定差距的, 希望自己能在阿里云发挥一定的价值. 欢迎感兴趣的同学联系我内推, 从<a href="https://job.alibaba.com/zhaopin/positionList.htm?keyWord=JTA4JXU5NjNGJXU5MUNDJXU0RTkx&amp;_input_charset=UTF-8&amp;spm=5176.191409.1013664.6.68a83002trVS9U&amp;acjoinus=AC008&amp;aly_as=W-f5n04l" target="_blank" rel="noopener">阿里云招聘官网</a>来看, 还是有不少 HC 的, 文末我放了二维码, 可以扫码加我微信(微信:tl3shi)详聊(请备注tanglei.name).  </p><p>其他生活上, 也没啥太多印象深刻的事情了, 旅游就去了趟泰国. 下半年周末游泳比较多, 也教会了老婆游泳了. 业余貌似也没有太多学习内容. </p><p>大家也能看到, 去年我的微信公众号也好, blog 也罢, 沉寂了一年, 都没更新过 🙃, 都有好友来催更过几次了 😭 </p><blockquote><p>(去年总结中的)意外收获是, 之前花1天时间学习了下小程序并写了一个简单的分期利率计算器, 然后试着玩玩加了广告, 没想到有时候广告收入有时候竟然能给加个🍗.</p></blockquote><p>报告一下<a href="https://www.tanglei.name/blog/summary-of-year-2018.html">去年总结</a>中的小程序加的鸡腿情况, 完全没有管的情况下, 依靠自然流量, 确确实实能加个鸡腿儿. 鸡腿得是学校卖的那种, 外面的太贵了, 不够 😝<br><img src="/resources/summary-of-year-2019/xiaochengxu-bonus.png" alt></p><p>从这个可以看出来, 不管做啥, 还是要确确实实解决具体的问题才有收获. 当初我做这个小程序的时候, 市场上基本没有, 只不过后来慢慢的多起来了, 也不乏有被抄袭的(还是一个公司). 不过后来我确实也从来没维护这个小程序了, 就让它在那里放着吧.  我在文末放了我的微信号, 感兴趣的同学可以加我私聊, 聊技术, 聊薅羊毛(哈哈, 这个小程序算不算)等等都行. </p><p>照旧说下新年愿望吧, 去年未完成的继续, 今年希望能多看看书.  </p><p>但愿这肺炎疫情早日结束, 愿大家健康, 平安.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;还是按照往年一样, 年终总结总是拖, 19年的比18年的总结相比, 出的时间差不多.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看看 &lt;a href=&quot;https://www.tanglei.name/blog/summary-of-year-2
      
    
    </summary>
    
      <category term="MyLife" scheme="https://www.tanglei.name/categories/MyLife/"/>
    
    
      <category term="总结" scheme="https://www.tanglei.name/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="MyLife" scheme="https://www.tanglei.name/tags/MyLife/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="https://www.tanglei.name/blog/summary-of-year-2018.html"/>
    <id>https://www.tanglei.name/blog/summary-of-year-2018.html</id>
    <published>2019-02-18T00:00:00.000Z</published>
    <updated>2020-07-09T15:00:32.562Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>还是按照往年一样, 年终总结总是拖, 18年的比<a href="/blog/summary-of-year-2017.html">17年的总结</a>又晚了一个多月. </p></blockquote><p>先看看17年年底的愿望实现多少了:</p><blockquote><p>说说 2018年的愿望吧, 希望新年里可以把人生大事给解决了, 希望在北京能有一个小窝, 希望大疆在北京的业务迅速发展, 自己能够发挥重要作用, 还有就是希望有一个好身体(大家得注意锻炼, 别跟我一样年纪轻轻就腰椎颈椎的出问题).</p></blockquote><p><img src="/resources/summary-of-year-2018/wedding-photo.jpg" alt="老婆求饶"></p><p><img src="/resources/summary-of-year-2018/wedding-bmw.jpeg" alt="骑着BMW娶亲"></p><p>18年总体来说还算不错: “把人生大事给解决了” 这条成就已达成 😁; “希望在北京能有一个小窝”, 这个也算达成了, 从此当上了房奴, 虽然小窝有点偏远, 在村里😂, 不过也还算好啦, 结合自身实际情况来看, 总体来说还算比较满意; 再然后公司的业务这块儿, 跟我的预期的还是有一定差距, 整体来说将将就就吧; “Last but not least”, 身体健康方面, 年度体检, “凸出”不再有了, 不过体重是蹭蹭往上长了些, 感觉就是”我控几不住我记几啊”(脑海浮现表情包).</p><p>工作方面, 我们北京team的同学从入职 DJI 就被发配到深圳, 终于在18年年初(春节后)的时候回到北京了, 刚回北京, 条件也比较艰苦, 租的是共享办公空间, 等自己办公区装修好之后才得以改善. 北京团队从最初的十人左右(我入职时), 到现在差不多四五十人吧. 期间走的走, 来的来, 属于正常流动也还算好. 这一年公司也出现了一些负面新闻, 年初的事情就是让各种安全整改, 搞得浩浩荡荡, 感觉整年都在围绕着这个话题在做; 年末的事情, 哎, 不提了, 都是泪. 从我接手相应的工作来看, 确实能看出一些问题, 公司在处于快速发展时期, 一些基础设施和相应规范流程不到位确实会引出很大安全隐患. 好在公司后面注意到这点, 也在逐步完善. </p><p><img src="/resources/summary-of-year-2018/dji-mavic-air-in-use.jpg" alt="图片来源于SkyPixel, 版权归原作者所有"><a href="https://www.skypixel.com/photos/dji-mavic-air-in-use" target="_blank" rel="noopener">图片来源于SkyPixel, 版权归原作者所有</a></p><p>这一年多, 自己还是围绕着业务来开展技术工作. 很多人觉得可能做业务没什么意思, 体现不了技术水平. 在这里我说下我自己的一点看法, 具体业务场景可能无外乎就是增删改查, 但不同的人写出来的增删改查, 其代码的可读性, 可维护性/扩展性, 性能等等都会有所差别的. 一名优秀的工程师就是能够在有限的资源(时间或人力等)内, 能针对某个具体的业务场景提出解决方案并高效地落地实施, 当然自己也是在朝着这个方向努力. 自己所接手的业务是历史遗留系统因为人员频繁交替缺少人维护, 所以要做很多”擦屁股”工作, 这也充分说明了一个项目初期架构, 文档, 代码等可扩展可维护的重要性. 在一个基本没什么人维护的历史遗留系统上做修改扩展本身就比较困难, 且又在一个跨一级部门的产品上做维护更是加大的难度. 通过一年的努力, 修修补补的也调整了不少, 但感觉离目标还有一段距离.  </p><p>这一年来, 还有一部分工作就是管理, 这方面的经验确实还不够. 年初团队一共也就2人, 根据当时的业务发展来说, 人力缺口还比较大, 然后一直就开始招聘, 这工作说起来简单, 真正做起来很困难. 一直到10月才招聘进新人入职. 如何困难? 一方面, DJI 在北京来说, 没什么名气, 在整个互联网圈, 貌似也没什么名气(不过DJI确实也不是一个互联网公司), 在没有名气的情况下, 吸引好的简历本身就比较困难, 再加上敝司的”综合测评”. 另外一个方面, 通过自己的圈子寻找优秀的同学过来面试, 最终通过了技术面试, 结果薪水上又不够有竞争力, 可能当时公司以深圳的市场水平来发放Offer(刚好北京那段时间市场真的不错). 要解决这个问题, 也不是我们这种虾兵蟹将能够解决的, 只能寄托于HR小姐姐帮忙, 最终HR小姐姐调研了北京的市场情况, 来回和总部协调沟通, 才让北京这边情况有所好转. 之前的一丁点管理经验感觉也就是把工作给大家分一分, 把握一下整体进度就OK了. 现在感觉也不是那么回事儿, 身上的责任会更大一些. 一方面, 要完成业务迭代功能, 保证业务进度和质量, 刚开始会想着一点工作, 可能自己做相比其他人做, 因为业务本身等的熟悉会更高效更高质量的产出, 但始终一个人的能力是有限的, 不能老是一个人做, 所以也希望要让团队里面的其他人也能做到这一点, 于是渐渐地让团队其他成员也承担更多的开发工作, 代码质量有问题, 就不断地靠Code Review, 靠流程去改善和提高; 除了业务开发之外, 另外一个方面, 就是希望团队成员在完成业务开发的同时, 仍然有技术追求, 要在技术上有所收获, 不让大家产生业务厌倦感, 这一点还需要在接下来的工作中继续努力; 还有, 一个团队中始终有能力强的产出高的, 每月的绩效考核也不应该完全一样, 怎么打才能做到相对公平, 公正和公开, 这一个也是需要慢慢去探索的.  </p><p>生活上, 貌似没有什么印象太深刻的, 旅游也比较少, 年初的时候在深圳, 带家人去港澳游玩了一圈, 其他旅游基本没了. 当然, 主要是在”够房”和”结婚”这两件事情占用了太多的业余时间. “购房”也是件体力活, 来来回回也看了三四十套吧, 总体来说还算运气好, 在”公积金”新政前买完了, 筛选房源 — 看房 — 再精选 — 谈判 — 成交跑流程, 很是费时间和精力. “结婚”也是, 前期婚纱照, 相册, 婚礼仪式流程等等, 然后自己家办了, 还有老婆家办酒席, 不过都是个”痛并快乐着”的事情.  </p><p>业余学习上貌似少了一些, 码字码得更少了😂, 在”极客时间”订阅了两门课程, 至今都没看1/3, 确实越来越懒了. 意外收获是, 之前花1天时间学习了下小程序并写了一个简单的分期利率计算器, 然后试着玩玩加了广告, 没想到有时候广告收入有时候竟然能给加个🍗. </p><p><img src="/resources/summary-of-year-2018/wechat-income.png" alt="微信小程序广告收入"></p><p>照例说说新年愿望吧, 在技术技能上能更进一步, 身体更健康一点(体重能稍微降点?), 能多看看外面的世界, 还有能不能让我汽车摇号摇中啊(遥了6年多了😂, 梦想还是要有的), 恩, 对了还有老家的🏡这个也需要解决下.</p><p>最后也祝愿大家在新的一年里各种顺利.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;还是按照往年一样, 年终总结总是拖, 18年的比&lt;a href=&quot;/blog/summary-of-year-2017.html&quot;&gt;17年的总结&lt;/a&gt;又晚了一个多月. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看看17年年底的愿望实现多少了:
      
    
    </summary>
    
      <category term="MyLife" scheme="https://www.tanglei.name/categories/MyLife/"/>
    
    
      <category term="总结" scheme="https://www.tanglei.name/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="MyLife" scheme="https://www.tanglei.name/tags/MyLife/"/>
    
  </entry>
  
</feed>
